[{"id":"4463bcb580e6af97fe7a8a01ae296a7e","title":"Vite 在开发模式使用 HTTPS","content":"在使用 Vite 进行前端开发的过程中，有时需要模拟一下 HTTPS 的环境（比如开启 PWA），但是如果直接设置server.https = true，浏览器会报您的连接不是私密连接这样的警告，那么该怎么做呢？\n仔细的查看了下文档，发现已经说的很清晰了server.https这个值也可以是一个传递给 https.createServer() 的 选项对象。下面是示例\n&#x2F;&#x2F; curl -k https:&#x2F;&#x2F;localhost:8000&#x2F;\nconst https &#x3D; require(&#39;https&#39;)\nconst fs &#x3D; require(&#39;fs&#39;)\n\nconst options &#x3D; &#123;\n  key: fs.readFileSync(&#39;test&#x2F;fixtures&#x2F;keys&#x2F;agent2-key.pem&#39;),\n  cert: fs.readFileSync(&#39;test&#x2F;fixtures&#x2F;keys&#x2F;agent2-cert.pem&#39;)\n&#125;\n\nhttps\n  .createServer(options, (req, res) &#x3D;&gt; &#123;\n    res.writeHead(200)\n    res.end(&#39;hello world\\n&#39;)\n  &#125;)\n  .listen(8000)\n\n我们要做的就是把 options 赋值给 server.https。当然还需要借助工具去生成 key 和 cert。\n操作步骤\n安装 mkcert\n我使用的是 Win10，就使用 choco 来安装了\nchoco install mkcert\n\n生成 key 和 cert\n为了便于管理我在项目的根目录下创建了 ssl 文件夹\nmkdir ssl\ncd ssl\nmkcert localhost\n\n操作完成后你会发现 ssl 目录下多了两个文件，也就是我们需要的 key 和 cert\nssl\n├── localhost-key.pem\n└── localhost.pem\n\n配置 vite.config.js\nimport &#123; defineConfig &#125; from &#39;vite&#39;\nimport path from &#39;path&#39;\nimport fs from &#39;fs&#39;\n\nexport default defineConfig(&#123;\n  server: &#123;\n    https: &#123;\n      key: fs.readFileSync(path.resolve(__dirname, &#39;.&#x2F;ssl&#x2F;localhost-key.pem&#39;)),\n      cert: fs.readFileSync(path.resolve(__dirname, &#39;.&#x2F;ssl&#x2F;localhost.pem&#39;))\n    &#125;\n  &#125;\n&#125;)\n\n下次在启动就能看到地址栏上的小锁头了 🔒\n\n\n\n\n\n\n\n\n\n\n\n[vite 要怎麼讓 localhost 也可以有 https 憑證？](https://penueling.com/技術筆記/要怎麼讓 localhost 也可以有 https 憑證？/)\n","slug":"Vite-HTTPS","date":"2021-06-21T03:06:53.000Z","categories_index":"前端","tags_index":"Vite","author_index":"ZV"},{"id":"91073ca00ced3eaf093ce066e8170e85","title":"C数据类型","content":"整型#include &lt;limits.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdio.h&gt;\n\nint main( int argc, char* argv[] ) &#123;\n  &#x2F;* 有符号整形 *&#x2F;\n  short     si &#x3D; 0;\n  int       i  &#x3D; 0;\n  long      li &#x3D; 0;\n  long long ll &#x3D; 0;\n  &#x2F;* 无符号整形 *&#x2F;\n  unsigned short     usi &#x3D; 0;\n  unsigned int       ui  &#x3D; 0;\n  unsigned long      uli &#x3D; 0;\n  unsigned long long ull &#x3D; 0;\n  printf( &quot;short               长度 : %d\\n&quot;, sizeof( short ) );               &#x2F;&#x2F; 2\n  printf( &quot;int                 长度 : %d\\n&quot;, sizeof( int ) );                 &#x2F;&#x2F; 4\n  printf( &quot;long                长度 : %d\\n&quot;, sizeof( long ) );                &#x2F;&#x2F; 4\n  printf( &quot;long long           长度 : %d\\n&quot;, sizeof( long long ) );           &#x2F;&#x2F; 8\n  printf( &quot;unsigned short      长度 : %d\\n&quot;, sizeof( unsigned short ) );      &#x2F;&#x2F; 2\n  printf( &quot;unsigned int        长度 : %d\\n&quot;, sizeof( unsigned int ) );        &#x2F;&#x2F; 4\n  printf( &quot;unsigned long       长度 : %d\\n&quot;, sizeof( unsigned long ) );       &#x2F;&#x2F; 4\n  printf( &quot;unsigned long long  长度 : %d\\n&quot;, sizeof( unsigned long long ) );  &#x2F;&#x2F; 8\n  printf( &quot;int                 范围 : %d &#x3D;&gt; %d\\n&quot;, INT_MIN, INT_MAX );        &#x2F;&#x2F; -2147483648 &#x3D;&gt; 2147483647\n  printf( &quot;unsigned int        范围 : %d &#x3D;&gt; %u\\n&quot;, 0, UINT_MAX );             &#x2F;&#x2F; 0 &#x3D;&gt; 4294967295\n  return 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\nsizeof 运算符可以返回变量或者变量类型的大小(单位:字节)\n\n由于 int 占据 4 个字节即 8 * 4 = 32 个 Bit，符号占有 Bit，所以\nINT_MIN = 2 ^ 31 * ( -1 )\nINT_MAX = 2 ^ 31 - 1\n\nprintf 中的格式字符\n\n\n\n格式字符\n意义\n\n\n\nd\n以十进制形式输出带符号整数(正数不输出符号10\n\n\no\n以八进制形式输出无符号整数(不输出前缀0)\n\n\nx\n以十六进制形式输出无符号整数(不输出前缀Ox)\n\n\nu\n以十进制形式输出无符号整数\n\n\nf\n以小数形式输出单、双精度实数\n\n\ne\n以指数形式输出单、双精度实数\n\n\ng\n以%f或%e中较短的输出宽度输出单、双精度实数\n\n\nc\n输出单个字符\n\n\ns\n输出字符串\n\n\np\n输出指针地址\n\n\nlu\n32位无符号整数\n\n\nllu\n64位无符号整数\n\n\n\n\n字符型#include &lt;limits.h&gt;\n#include &lt;stdio.h&gt;\n\nint main( int argc, char* argv[] ) &#123;\n  char char_a &#x3D; &#39;a&#39;;\n  int  int_a  &#x3D; 97;\n  printf( &quot;char 长度 : %d\\n&quot;, sizeof( char ) );    &#x2F;* 1 *&#x2F;\n  printf( &quot;int  长度 : %d\\n&quot;, sizeof( int ) );     &#x2F;* 4 *&#x2F;\n  printf( &quot;使用 %%d 格式化 char : %d\\n&quot;, char_a ); &#x2F;* 97 *&#x2F;\n  printf( &quot;使用 %%c 格式化 char : %c\\n&quot;, char_a ); &#x2F;* a *&#x2F;\n  printf( &quot;使用 %%d 格式化 int  : %d\\n&quot;, int_a );  &#x2F;* 97 *&#x2F;\n  printf( &quot;使用 %%c 格式化 int  : %c\\n&quot;, int_a );  &#x2F;* a *&#x2F;\n&#125;\n\n\n\n\n\n\n\n\n\n\n其实呢，这部分能看出 char 和 int 只是从不同角度观察了同一个东西\n我们可以从 JS 的角度来看一下\nString.fromCharCode(97) &#x2F;&#x2F; &#39;a&#39;\n&#39;a&#39;.charCodeAt() &#x2F;&#x2F; 97\n\n不过 JS 中并没有 char 这个概念，97 与 ‘a’ 的相等也就更无从提及了\nxdm 注意了啊，下面分别用各种方式定义的量竟然都是一样的\n#include &lt;stdio.h&gt;\n\nint main( int argc, char* argv[] ) &#123;\n  &#x2F;* 首先排除 char 代表队 *&#x2F;\n  char char_a     &#x3D; &#39;a&#39;;\n  char char_a_oct &#x3D; &#39;\\141&#39;;\n  char char_a_hex &#x3D; &#39;\\x61&#39;;\n  &#x2F;* 接下来有请 int 代表队 *&#x2F;\n  int int_a     &#x3D; 97;\n  int int_a_oct &#x3D; 0141;\n  int int_a_hex &#x3D; 0x61;\n  &#x2F;* 然后打印康康 *&#x2F;\n  printf( &quot;使用 %%c 格式化\\n&quot; );\n  printf( &quot;char_a     : %c\\n&quot;, char_a );     &#x2F;* a *&#x2F;\n  printf( &quot;char_a_oct : %c\\n&quot;, char_a_oct ); &#x2F;* a *&#x2F;\n  printf( &quot;char_a_hex : %c\\n&quot;, char_a_hex ); &#x2F;* a *&#x2F;\n  printf( &quot;int_a      : %c\\n&quot;, int_a );      &#x2F;* a *&#x2F;\n  printf( &quot;int_a_oct  : %c\\n&quot;, int_a_oct );  &#x2F;* a *&#x2F;\n  printf( &quot;int_a_hex  : %c\\n&quot;, int_a_hex );  &#x2F;* a *&#x2F;\n  printf( &quot;使用 %%d 格式化\\n&quot; );\n  printf( &quot;char_a     : %d\\n&quot;, char_a );     &#x2F;* 97 *&#x2F;\n  printf( &quot;char_a_oct : %d\\n&quot;, char_a_oct ); &#x2F;* 97 *&#x2F;\n  printf( &quot;char_a_hex : %d\\n&quot;, char_a_hex ); &#x2F;* 97 *&#x2F;\n  printf( &quot;int_a      : %d\\n&quot;, int_a );      &#x2F;* 97 *&#x2F;\n  printf( &quot;int_a_oct  : %d\\n&quot;, int_a_oct );  &#x2F;* 97 *&#x2F;\n  printf( &quot;int_a_hex  : %d\\n&quot;, int_a_hex );  &#x2F;* 97 *&#x2F;\n  printf( &quot;使用 %%o 格式化\\n&quot; );\n  printf( &quot;char_a     : %o\\n&quot;, char_a );     &#x2F;* 141 *&#x2F;\n  printf( &quot;char_a_oct : %o\\n&quot;, char_a_oct ); &#x2F;* 141 *&#x2F;\n  printf( &quot;char_a_hex : %o\\n&quot;, char_a_hex ); &#x2F;* 141 *&#x2F;\n  printf( &quot;int_a      : %o\\n&quot;, int_a );      &#x2F;* 141 *&#x2F;\n  printf( &quot;int_a_oct  : %o\\n&quot;, int_a_oct );  &#x2F;* 141 *&#x2F;\n  printf( &quot;int_a_hex  : %o\\n&quot;, int_a_hex );  &#x2F;* 141 *&#x2F;\n  printf( &quot;使用 %%x 格式化\\n&quot; );\n  printf( &quot;char_a     : %x\\n&quot;, char_a );     &#x2F;* 61 *&#x2F;\n  printf( &quot;char_a_oct : %x\\n&quot;, char_a_oct ); &#x2F;* 61 *&#x2F;\n  printf( &quot;char_a_hex : %x\\n&quot;, char_a_hex ); &#x2F;* 61 *&#x2F;\n  printf( &quot;int_a      : %x\\n&quot;, int_a );      &#x2F;* 61 *&#x2F;\n  printf( &quot;int_a_oct  : %x\\n&quot;, int_a_oct );  &#x2F;* 61 *&#x2F;\n  printf( &quot;int_a_hex  : %x\\n&quot;, int_a_hex );  &#x2F;* 61 *&#x2F;\n  return 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n从上面的实验可以看出：\n你可以用不同的方式来表示一个 int 或者 char（ 字符、8进制字符、16进制字符、整形、8进制整形、16进制的整形 ）\n你也可以用不同的方式来展示一个 int 或者 char （%d、%c、%o、%x）\n这里有个小问题：在 1 个 char 的大小是 1 个字节（ 8 个 Bit ），所以最多也就是能表示 256（2 ^ 8）种字符，  那么像单个汉字要或者其他的语言文字要怎么表示呢？\n这里就需要引入 Unicode 字符集了\nint main( int argc, char* argv[] ) &#123;\n  &#x2F;* C95 开始支持 Unicode*&#x2F;\n  wchar_t qi &#x3D; L&#39;七&#39;;\n  printf( &quot;wchar_t 长度 : %d\\n&quot;, sizeof( wchar_t ) ); &#x2F;* 2 *&#x2F;\n  return 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\nTODO : 打印宽字符\n浮点型#include &lt;float.h&gt;\n#include &lt;limits.h&gt;\n#include &lt;stdio.h&gt;\n\nint main( int argc, char* argv[] ) &#123;\n  float       f  &#x3D; 3.14f;\n  double      d  &#x3D; 3.14;\n  long double ld &#x3D; 3.14;\n  printf( &quot;float       长度 : %d\\n&quot;, sizeof( float ) );        &#x2F;* 4 *&#x2F;\n  printf( &quot;double      长度 : %d\\n&quot;, sizeof( double ) );       &#x2F;* 8 *&#x2F;\n  printf( &quot;long double 长度 : %d\\n&quot;, sizeof( long double ) );  &#x2F;* 16 *&#x2F;\n  printf( &quot;float       范围 : %e &#x3D;&gt; %e\\n&quot;, FLT_MIN, FLT_MAX ); &#x2F;* 1.175494e-038 &#x3D;&gt; 3.402823e+038 *&#x2F;\n  printf( &quot;double      范围 : %e &#x3D;&gt; %e\\n&quot;, DBL_MIN, DBL_MAX ); &#x2F;* 2.225074e-308 &#x3D;&gt; 1.797693e+308 *&#x2F;\n  printf( &quot;float       精度 : %d\\n&quot;, FLT_DIG );                &#x2F;* 6 *&#x2F;\n  printf( &quot;double      精度 : %d\\n&quot;, DBL_DIG );                &#x2F;* 15 *&#x2F;\n  return 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n注意：表示金钱的时候，不要用 float 类型，容易出现精度损失\n","slug":"C数据类型","date":"2021-06-18T02:52:41.000Z","categories_index":"拓展","tags_index":"C","author_index":"ZV"},{"id":"e1904a6ce18376ef8b5f00b597175c9f","title":"C指针","content":"什么是指针 &amp; 指针变量\n\n\n\n\n\n\n\n\n指针就是变量的内存地址，而用来存储指针的变量则是指针变量。\n指针变量的声明&#x2F;* type *var-name; *&#x2F;\nint    *ip;\ndouble *dp;\nfloat  *fp;\nchar   *ch;\n\n\n\n\n\n\n\n\n\n\n\n在这里，type 是指针的基类型，它必须是一个有效的 C 数据类型，var-name 是指针变量的名称。\n所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。\n不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。\n\n举个例子#include &lt;stdio.h&gt;\n\nint main() &#123;\n  int  v         &#x3D; 1;  &#x2F;* 声明实际变量*&#x2F;\n  int* v_pointer &#x3D; &amp;v; &#x2F;* 声明指针变量*&#x2F;\n  printf( &quot;变量 : %i\\n&quot;, v );\n  printf( &quot;指针 : %i\\n&quot;, &amp;v );\n  printf( &quot;指针变量 : %i\\n&quot;, v_pointer );\n  printf( &quot;使用指针变量访问变量: %i\\n&quot;, *v_pointer );\n  return 0;\n&#125;\n&#x2F;* \n  变量 : 1\n  指针 : 6422036\n  指针变量 : 6422036\n  使用指针变量访问变量: 1\n *&#x2F;\n\n\n\n\n\n\n\n\n\n\n*运算符和&amp;运算符恰好相反。\n&amp;运算符接收一个数据，然后告诉你这个数据保存在哪里；\n*运算符接收一个地址，然后告诉你这个地址中保存的是什么数据。\n为什么用指针呢首先看一个问题\n#include &lt;stdio.h&gt;\n\nvoid add( int v ) &#123;\n  v &#x3D; v + 1;\n&#125;\n\nint main() &#123;\n  int x &#x3D; 10;\n  printf( &quot;增加前 : %i\\n&quot;, x );\n  add( x );\n  printf( &quot;增加后 : %i\\n&quot;, x );\n  return 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n这段代码的本意是想通过 add 函数，使变量 x 增加 1\n但是当调用 add 函数的时候，它只是将变量 x 赋值给了 v 并使用，这只是一个单纯的赋值过程\n所以后续的v = v + 1只会改变 v 的值，并不会对 x 产生任何效果。\n那怎么办呢？\n简单来讲，可以让 add 函数把结果返回出去，并重新赋值给 x\n#include &lt;stdio.h&gt;\n\nint add( int v ) &#123;\n  v &#x3D; v + 1;\n  return v;\n&#125;\n\nint main() &#123;\n  int x &#x3D; 10;\n  printf( &quot;增加前 : %i\\n&quot;, x );\n  x &#x3D; add( x );\n  printf( &quot;增加后 : %i\\n&quot;, x );\n  return 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n这此好多了，结果也符合预期，但是还有没有其他方法呢？\n答案是有，那就是使用指针\n#include &lt;stdio.h&gt;\n\nvoid add( int* v ) &#123; &#x2F;&#x2F; 定义指针变量\n  *v &#x3D; *v + 1; &#x2F;&#x2F; 通过指针变量操作指针指向的变量\n&#125;\n\nint main() &#123;\n  int x &#x3D; 10;\n  printf( &quot;增加前 : %i\\n&quot;, x );\n  add( &amp;x ); &#x2F;&#x2F; 传递指针\n  printf( &quot;增加后 : %i\\n&quot;, x );\n  return 0;\n&#125;\n\n指向指针的指针讲真这块有点老千层饼了，不过也不难\n#include &lt;stdio.h&gt;\n\nint main() &#123;\n  int   v;\n  int*  p1;\n  int** p2;\n  v  &#x3D; 10;\n  p1 &#x3D; &amp;v;\n  p2 &#x3D; &amp;p1;\n  printf( &quot;实际变量 v %i\\n&quot;, v );\n  printf( &quot;指针变量 p1 %i\\n&quot;, p1 );\n  printf( &quot;指针变量 p2 %i\\n&quot;, p2 );\n  printf( &quot;使用p2访问p1 %i\\n&quot;, *p2 );\n  printf( &quot;使用p1访问实际变量 %i\\n&quot;, *p1 );\n  printf( &quot;使用p2访问实际变量 %i\\n&quot;, **p2 );\n  printf( &quot;p1 与  *p2 %i\\n&quot;, p1 &#x3D;&#x3D; *p2 );\n  printf( &quot;v  与  *p1 %i\\n&quot;, v &#x3D;&#x3D; *p1 );\n  printf( &quot;v  与 **p2 %i\\n&quot;, v &#x3D;&#x3D; **p2 );\n  return 0;\n&#125;\n\n","slug":"C指针","date":"2021-06-17T05:12:05.000Z","categories_index":"拓展","tags_index":"C","author_index":"ZV"},{"id":"a5b603fdecca7f9969a0f73abd417029","title":"JS的三种继承","content":"ES6 Classclass Person &#123;\n  constructor(name, age) &#123;\n    this.name &#x3D; name\n    this.age &#x3D; age\n  &#125;\n  getInfo() &#123;\n    return &#96;name : $&#123;this.name&#125; $&#123;this.age&#125;&#96;\n  &#125;\n&#125;\n\nclass Student extends Person &#123;\n  constructor(name, age, grade) &#123;\n    super(name, age)\n    this.grade &#x3D; grade\n  &#125;\n  getGrade() &#123;\n    return &#96;grade : $&#123;this.grade&#125;&#96;\n  &#125;\n&#125;\n\nconst s1 &#x3D; new Student(&#39;Jack&#39;, 17, 100)\nconst s2 &#x3D; new Student(&#39;Tim&#39;, 19, 90)\n\n寄生组合式继承function Person(name, age) &#123;\n  this.name &#x3D; name\n  this.age &#x3D; age\n&#125;\n\nPerson.prototype.getInfo &#x3D; function () &#123;\n  return &#96;name : $&#123;this.name&#125; $&#123;this.age&#125;&#96;\n&#125;\n\nfunction Student(name, age, grade) &#123;\n  Person.call(this, name, age)\n  this.grade &#x3D; grade\n&#125;\n\nStudent.prototype &#x3D; Object.create(Person.prototype)\n\nStudent.prototype.getGrade &#x3D; function () &#123;\n  return &#96;grade : $&#123;this.grade&#125;&#96;\n&#125;\n\nStudent.prototype.constructor &#x3D; Student\n\nconst s1 &#x3D; new Student(&#39;Jack&#39;, 17, 100)\nconst s2 &#x3D; new Student(&#39;Tim&#39;, 19, 90)\n\nOLOO ( Objects Linked to Other Objects )&#x2F;&#x2F; 使用 OLOO 的方式重构继承\n&#x2F;&#x2F; 创建 Person 对象\nconst Person &#x3D; &#123;\n  init(name, age) &#123;\n    this.name &#x3D; name\n    this.age &#x3D; age\n    return this\n  &#125;,\n  getInfo() &#123;\n    return &#96;name : $&#123;this.name&#125;\\n age : $&#123;this.age&#125;&#96;\n  &#125;\n&#125;\nconst p1 &#x3D; Object.create(Person).init(&#39;Tim&#39;, 20)\n\n&#x2F;* \n  使用 Object.create 创建一个以 Person 为原型的 Student 对象\n  Student 的 init 方法在原型链上会先比 Person 的 init 方法先被找到，所以不用担心\n  ---- Student 结构图 ----\n  ➡️ getGrade: ƒ ()\n  ➡️ init: ƒ (name, age, grade)\n  ⬇️ __proto__:\n    ➡️ getInfo: ƒ getInfo()\n    ➡️ init: ƒ init(name, age)\n    ➡️ __proto__: Object \n*&#x2F;\nconst Student &#x3D; Object.create(Person)\nStudent.init &#x3D; function (name, age, grade) &#123;\n  Person.init.call(this, name, age)\n  this.grade &#x3D; grade\n  return this\n&#125;\nStudent.getGrade &#x3D; function () &#123;\n  return &#96;grade : $&#123;this.grade&#125;&#96;\n&#125;\nconst s1 &#x3D; Object.create(Student).init(&#39;Jack&#39;, 17, 100)\nconst s2 &#x3D; Object.create(Student).init(&#39;Tim&#39;, 19, 90)\n\n\n\n","slug":"JS的三种继承","date":"2021-04-17T11:04:48.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"ZV"},{"id":"0ec65ba286b3197dc2b4ec62da6fde2a","title":"对象链接的方法","content":"对象链接也叫 OLOO ( Objects Linked to Other Objects )， 说的直白一点就是对象 A 链接对象 B，对象 A 可以访问对象 B 的属性和方法。\n举个🌰，我们创建一个工具对象 BasicFormatter，然后通过不同的方式创建可以访问 BasicFormatter 的工具对象\nconst BasicFormatter &#x3D; &#123;\n  format: function (msg) &#123;\n    return msg.toUpperCase()\n  &#125;\n&#125;\n\n隐式&#x2F;* \n  Implicit 隐式\n  通过 Object.create 方法创建一个以 BasicFormatter 为原型的对象\n  这样就能通过 __proto__ 调用原型链上的 format 函数 \n*&#x2F;\nconst Foo &#x3D; Object.create(BasicFormatter)\nFoo.saySomething &#x3D; function (msg) &#123;\n  console.log(this.format(msg))\n&#125;\n\nFoo.saySomething(&#39;this is foo!&#39;)\n\n显式&#x2F;* \n  Explicit 显式\n  直接把需要链接的对象定义在自身上\n*&#x2F;\nconst Bar &#x3D; &#123;\n  formatter: BasicFormatter,\n  saySomething(msg) &#123;\n    console.log(this.formatter.format(msg))\n  &#125;\n&#125;\n\nBar.saySomething(&#39;this is bar!&#39;)\n\n","slug":"对象链接的方法","date":"2021-04-10T11:26:01.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"ZV"},{"id":"5e422a9b2c69bd7294ec71b84cbbb53b","title":"单例模式","content":"代码实现以数据库连接为例简单实现一个单例\nclass Database &#123;\n  constructor(options) &#123;\n    this.options &#x3D; options\n  &#125;\n  getConnection() &#123;\n    console.log(&#39;You are now connected to the database.&#39;)\n  &#125;\n&#125;\n\nconst DatabaseSingleton &#x3D; (function () &#123;\n  let instance &#x3D; null\n  return function (options) &#123;\n    if (instance &#x3D;&#x3D;&#x3D; null) &#123;\n      instance &#x3D; new Database(options)\n    &#125;\n    return instance\n  &#125;\n&#125;)()\n\nconst db1 &#x3D; new DatabaseSingleton(&#123; host: &#39;localhost&#39;, port: 1111 &#125;)\nconst db2 &#x3D; new DatabaseSingleton(&#123; host: &#39;localhost&#39;, port: 2222 &#125;)\nconsole.log(db1 &#x3D;&#x3D;&#x3D; db2) &#x2F;&#x2F; true\n\n通用实现通用的单例模式一般由以下几个部分构成\n\nSingleton ：特定类，这是我们需要访问的类，访问者要拿到的是它的实例；\ninstance ：单例，是特定类的实例，特定类一般会提供 getInstance 方法来获取该单例；\ngetInstance ：获取单例的方法，或者直接由 new 操作符获取；\n\nclass Singleton &#123;\n  static instance &#x3D; null\n  static getInstance(options) &#123;\n    if (Singleton.instance &#x3D;&#x3D;&#x3D; null) &#123;\n      return new Singleton(options)\n    &#125;\n    return Singleton.instance\n  &#125;\n  constructor(options) &#123;\n    if (Singleton.instance &#x3D;&#x3D;&#x3D; null) &#123;\n      this.options &#x3D; options\n      Singleton.instance &#x3D; this\n    &#125;\n    return Singleton.instance\n  &#125;\n&#125;\n\nconst s1 &#x3D; new Singleton(&#39;s1&#39;)\nconst s2 &#x3D; Singleton.getInstance(&#39;s2&#39;)\nconsole.log(s1 &#x3D;&#x3D;&#x3D; s2) &#x2F;&#x2F; true\n\n懒汉式 vs 饿汉式懒汉式和饿汉式的区别就在于单例 instance 是否是懒加载的\n懒汉式function Money(currency, amount) &#123;\n  this.currency &#x3D; currency\n  this.amount &#x3D; amount\n&#125;\n\nMoney.prototype.getMoney &#x3D; function () &#123;\n  return &#96;$&#123;this.currency&#125; $&#123;this.amount&#125;&#96;\n&#125;\n\nconst MoneySingletonLazy &#x3D; (function () &#123;\n  let instance &#x3D; null\n  return function (currency, amount) &#123;\n    if (instance &#x3D;&#x3D;&#x3D; null) &#123;\n      instance &#x3D; new Money(currency, amount) &#x2F;&#x2F; 懒加载\n    &#125;\n    return instance\n  &#125;\n&#125;)()\n\nconst m1 &#x3D; MoneySingletonLazy(&#39;$&#39;, 100)\nconst m2 &#x3D; MoneySingletonLazy(&#39;$&#39;, 100)\nconsole.log(m1 &#x3D;&#x3D;&#x3D; m2)\n\n饿汉式function Money(currency, amount) &#123;\n  this.currency &#x3D; currency\n  this.amount &#x3D; amount\n&#125;\n\nMoney.prototype.getMoney &#x3D; function () &#123;\n  return &#96;$&#123;this.currency&#125; $&#123;this.amount&#125;&#96;\n&#125;\n\nconst MoneySingletonHungry &#x3D; (function (currency, amount) &#123;\n  const instance &#x3D; new Money(currency, amount) &#x2F;&#x2F; 直接加载\n  return function () &#123;\n    return instance\n  &#125;\n&#125;)(&#39;$&#39;, 100)\n\nconst m1 &#x3D; MoneySingletonHungry()\nconst m2 &#x3D; MoneySingletonHungry()\nconsole.log(m1 &#x3D;&#x3D;&#x3D; m2)\n\n优缺点优点\n单例模式在创建后在内存中只存在一个实例，节约了内存开支和实例化时的性能开支，特别是需要重复使用一个创建开销比较大的类时，比起实例不断地销毁和重新实例化，单例能节约更多资源，比如数据库连接；\n单例模式可以解决对资源的多重占用，比如写文件操作时，因为只有一个实例，可以避免对一个文件进行同时操作；\n只使用一个实例，也可以减小垃圾回收机制 GC（Garbage Collecation） 的压力，表现在浏览器中就是系统卡顿减少，操作更流畅，CPU 资源占用更少；\n\n缺点\n单例模式对扩展不友好，一般不容易扩展，因为单例模式一般自行实例化，没有接口；\n与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化；\n\n使用场景\n当一个类的实例化过程消耗的资源过多，可以使用单例模式来避免性能浪费；\n当项目中需要一个公共的状态，那么需要使用单例模式来保证访问一致性；\n\n","slug":"单例模式","date":"2021-03-02T00:47:39.000Z","categories_index":"前端","tags_index":"JavaScript,设计模式","author_index":"ZV"},{"id":"6e749354fe99cad36f08dba2ac6a28a4","title":"100个单词-01","content":"01-10\n\n\n词\n译\n\n\n\ndistributed\nadj. 分布式的，分散式的\n\n\ndecentralized\nadj. 分散管理的 vt. 使分散；使分权（decentralize 的过去分词）\n\n\ndeliver\nvt. 交付；发表；递送；释放；给予（打击）\n\n\nintermediate\nadj. 中间的，过渡的；中级的，中等的\n\n\ninternet traffic\n网络流量\n\n\ndirect\nvt. 管理；指挥；导演；指向\n\n\ntransmits\nvt. 传输；传播；发射；传达；遗传\n\n\ndelivery\nn. [贸易] 交付；分娩；递送\n\n\nstumbled onto\n偶然找到；碰上\n\n\ndiametrically\nadv. 完全地；作为直径地；直接地；正好相反地\n\n\n11-20\n\n\n词\n译\n\n\n\nencapsulating\nn. 封装；[电] 包封 v. 封进内部（encapsulate 的 ing 形式）\n\n\na slew of\n大量的\n\n\nget away from\n避免，摆脱；逃离\n\n\nmechanism\nn. 机制；原理，途径；进程；机械装置；技巧\n\n\nit dawned on me that\n突然醒悟；忽然觉悟；忽然醒悟\n\n\ncomposable\nadj. 组成的\n\n\nfrustrating\nadj. 令人沮丧的 v. 使沮丧（frustrate 的 ing 形式）\n\n\npropel\nvt. 推进；驱使；激励；驱策\n\n\nthe sheer number of\n……的数目\n\n\ndig into\n深入钻研；钻研；挖掘\n\n\n21-30\n\n\n词\n译\n\n\n\nproposal\nn. 提议，建议；求婚\n\n\nmanuscript\nn. [图情] 手稿；原稿 adj. 手写的\n\n\nperspective\nn. 观点；远景；透视图 adj. 透视的\n\n\nFirst and foremost\n首先；首要的是\n\n\nfatigue\nn. 疲劳，疲乏；杂役 vt. 使疲劳；使心智衰弱 vi. 疲劳 adj. 疲劳的\n\n\nsynthesize\nvt. 合成；综合\n\n\nspotlight on\n关注\n\n\ncapabilities\nn. 能力（capability的复数）；功能；性能\n\n\npermeates\nv. 弥漫（permeate的第三人称单数）\n\n\nmetaprogramming\n元编程\n\n\n31-40\n\n\n词\n译\n\n\n\nbreadth\nn. 宽度，幅度；宽宏\n\n\npassionate\nadj. 热情的；热烈的，激昂的；易怒的\n\n\ncatch up\n赶上；把…缠住\n\n\nin order\n整齐，秩序井然；按顺序；状况良好\n\n\nsheds light on\n阐明；使…清楚地显出\n\n\nsyntactical\nadj. 句法的；依照句法的（等于syntactic）\n\n\ninheritance\nn. 继承；遗传；遗产\n\n\ndomain\nn. 领域；域名；产业；地产 n. (Domain)人名；(英、法)多曼\n\n\ntake advantage of\n利用；占便宜；欺负；趁\n\n\nproper\nadj. 适当的；本身的；特有的；正派的\n\n\ncohesive\nadj. 凝聚的；有结合力的；紧密结合的；有粘着力的\n\n\n41-50\n\n\n词\n译\n\n\n\ndespite\nprep. 即使，尽管 n. （诗/文）侮辱，伤害；轻视，鄙视；憎恨 vt. &lt;废语&gt;故意使烦恼，故意伤害；&lt;古&gt;蔑视，轻蔑\n\n\nfar from\nadv. 远离；远非；完全不\n\n\nunderlying\nadj. 潜在的；根本的；在下面的；优先的 v. 放在…的下面；为…的基础；优先于（underlie的ing形式）\n\n\nmalleable\nadj. 可锻的；可塑的；有延展性的；易适应的\n\n\nversatile\nadj. 多才多艺的；通用的，万能的；多面手的\n\n\nexpose\nvt. 揭露，揭发；使曝光；显示\n\n\ninstantiate\nv. 例示，举例说明；（哲）有例为证\n\n\npros and  cons\n正反两方面；赞成者和反对者\n\n\nBelieve it or not\n信不信由你\n\n\nmodular\nadj. 模块化的；模数的；有标准组件的\n\n\n51-60\n\n\n词\n译\n\n\n\nalgebraic data types (ADT)\n代数数据类型\n\n\nidiom\nn. 成语，习语；土话\n\n\naka\nabbr. 又名，亦称 (also known as)\n\n\nevaluating\nv. 评估（evaluate的ing形式\n\n\nseparation\nn. 分离，分开；间隔，距离；[法] 分居；缺口\n\n\ntoasters\nn. 烤箱；烤面包器\n\n\nrefrigerators\nn. [制冷] 冰箱，[制冷] 冷藏室；[制冷] 冷冻库（refrigerator的复数）\n\n\nthermostats\nn. 恒温控制器，温度调节装置（thermostat 的复数）\n\n\nspacesuits\nn. 航天服；太空服\n\n\nall tiers of\n…… 的所有层\n\n\n61-70\n\n\n词\n译\n\n\n\nfingertip\nn. （手）指尖；指套 adj. 容易接近的；延长到指尖的（如外套或面纱）\n\n\nprearranged\nadj. 预定的，预先安排的 v. 预定（prearrange的过去分词）；预先安排\n\n\nbusiness-domain logic\n业务领域逻辑\n\n\nuncertain\nadj. 无把握的；多变的；不确定的；信心不足的；靠不住的\n\n\nfor these cases\n针对这类状况\n\n\ngrasp\nv. 抓牢，握紧；试图抓住；理解，领悟；毫不犹豫地抓住（机会）n. 抓，握；理解，领会；力所能及，把握；权力，控制\n\n\nparadigm\nn. 范例；词形变化表\n\n\ngeneral-purpose\nadj. 多用途的；一般用途的\n\n\ndemand\nn. （坚决的或困难的）要求；（顾客的）需求 v. 强烈要求；需要；逼问；查问，查询\n\n\nimpose\nvi. 利用；欺骗；施加影响 vt. 强加；征税；以…欺骗\n\n\n71-80\n\n\n词\n译\n\n\n\nIn addition\n另外，此外\n\n\nat scale\n大规模地\n\n\ndecomposing\nv. 腐烂；分解（decompose 的现在分词）\n\n\npotentially\nadv. 可能地，潜在地\n\n\nidentify\nvt. 确定；鉴定；识别，辨认出；使参与；把……看成一样 vi. 确定；认同；一致\n\n\nwell-rounded\nadj. 丰满的；面面俱到的；多才多艺的；（语句）有表达力的\n\n\ntackle\nv. 应付，处理（难题或局面）；与某人交涉；（足球、曲棍球等）抢球；（橄榄球或美式足球）擒抱摔倒；抓获；对付，打（尤指罪犯）\n\n\nleaner\nadj. 更精瘦而且健康的，脂肪更少的；更贫乏的，更不足的；更精干的，效率更高的；更低报酬的\n\n\nelegant\nadj. 高雅的，优雅的；讲究的；简炼的；简洁的\n\n\nIn short\n总之；简言之\n\n\n81-90\n\n\n词\n译\n\n\n\nemerge\nvi. 浮现；摆脱；暴露\n\n\na batch of\n一批\n\n\ndisposal\nn. 处理；支配；清理；安排\n\n\ncumbersome\nadj. 笨重的；累赘的；难处理的\n\n\nhierarchy\nn. 层级；等级制度\n\n\ncompatible\nadj. 兼容的；能共处的；可并立的\n\n\nthe lack of\n缺乏；没有\n\n\ncringe\nvi. 畏缩；奉承；阿谀 n. 畏缩；奉承\n\n\nimplementing\nv. 贯彻，实行（implement 的现在分词）\n\n\ntransparently\nadv. 显然地，易觉察地；明亮地\n\n\n91-100\n\n\n词\n译\n\n\n\nangst\n忧虑,不安\n\n\ninevitably\nadv. 不可避免地；必然地\n\n\nembrace\nvt. 拥抱；欣然采纳；信奉；包含\n\n\nstigma\nn. [植] 柱头；耻辱；污名；烙印；特征\n\n\nsentiment\nn. 感情，情绪；情操；观点；多愁善感\n\n\nvibrant\nadj. 充满生机的，生气勃勃的；鲜艳的；醒目的；洪亮的；强劲的；颤抖的，震动的\n\n\nmisconception\nn. 误解；错觉；错误想法\n\n\nspectrum\nn. 光谱；频谱；范围；余象\n\n\ninferior\nadj. 差的；自卑的；下级的，下等的 n. 下级；次品\n\n\nresounding\nadj. 响亮的；轰动的；彻底的 v. 回响（resound的ing形式）\n\n\n","slug":"100个单词-01","date":"2021-02-09T13:55:12.000Z","categories_index":"拓展","tags_index":"单词","author_index":"ZV"},{"id":"defa8072864be9cd1bcb03fd50d832a5","title":"申请LetsEncrypt通配符SSL证书","content":"获取 Certbot 客户端# 下载 Certbot 客户端\nwget https:&#x2F;&#x2F;dl.eff.org&#x2F;certbot-auto\n\n# 设为可执行权限\nchmod a+x certbot-auto\n\n申请通配符证书.&#x2F;certbot-auto certonly  -d &quot;*.emotionl.fun&quot; --manual --preferred-challenges dns-01  --server https:&#x2F;&#x2F;acme-v02.api.letsencrypt.org&#x2F;directory\n\n完这一步之后，请根据命令行的提示输入相应内容\n","slug":"申请LetsEncrypt通配符SSL证书","date":"2021-01-26T03:49:01.000Z","categories_index":"运维","tags_index":"Nginx,Linux","author_index":"ZV"},{"id":"2afb485f1ca3d275b575e077ea3a1ee9","title":"前端开发规范","content":"\n\n\n\n\n\n\n\n\n此规范基于 阿里前端开发规范 | Tim 并结合实际项目进行部分修改\n一、编程规约(一) 命名规范1.1.1 项目命名全部采用小写方式， 以中划线分隔。\n正例：mall-management-system\n反例：mall_management-system / mallManagementSystem\n1.1.2 目录命名全部采用小写方式， 以中划线分隔，有复数结构时，要采用复数命名法， 缩写不用复数\n正例： scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc\n反例： script / style / demo_scripts / demoStyles / imgs / docs\n【特殊】Vue 项目中的 components 和 view 中的组件目录和组件名，使用单词大写开头 (PascalCase) 命名\n正例： HeadSearch / PageLoading\n反例： head-search / page-loading / mycomponent / myComponent\n1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名全部采用小写方式， 以中划线分隔\n正例： render-dom.js / signup.css / index.html / company-logo.png\n反例： renderDom.js / UserManagement.html\n1.1.4 命名严谨性代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用\n正例：henan / luoyang / rmb 等国际通用的名称，可视同英文。\n反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3\n杜绝完全不规范的缩写，避免望文不知义：\n反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。\n(二) HTML 规范 （Vue Template 同样适用）1.2.1 HTML 类型推荐使用 HTML5 的文档类型申明：（建议使用 text/html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application/xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。\n\n规定字符编码\nIE 兼容模式\ndoctype 大写\n\n正例：\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;Edge&quot; &#x2F;&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Page title&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;img src&#x3D;&quot;images&#x2F;company-logo.png&quot; alt&#x3D;&quot;Company&quot; &#x2F;&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n1.2.2 缩进缩进使用 2 个空格（一个 tab）\n嵌套的节点应该缩进。\n1.2.3 分块注释在每一个块状元素，列表元素和表格元素后，加上一对 HTML 注释。注释格式\n正例：\n&lt;body&gt;\n  &lt;!-- header 头部 start --&gt;\n  &lt;header&gt;\n    &lt;div class&#x3D;&quot;container&quot;&gt;\n      &lt;a href&#x3D;&quot;#&quot;&gt;\n        &lt;!-- 图片会把a标签给撑开，所以不用设置a标签的大小 --&gt;\n        &lt;img src&#x3D;&quot;images&#x2F;header.jpg&quot; &#x2F;&gt;\n      &lt;&#x2F;a&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;header&gt;\n  &lt;!-- header 头部 end --&gt;\n&lt;&#x2F;body&gt;\n\n1.2.4 语义化标签HTML5 中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是 div 或者 p 标签\n正例\n&lt;header&gt;&lt;&#x2F;header&gt;\n&lt;footer&gt;&lt;&#x2F;footer&gt;\n\n反例\n&lt;div&gt;\n  &lt;p&gt;&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n\n1.2.5 引号使用双引号(“ “) 而不是单引号(‘ ‘) 。\n(三) CSS 规范1.3.1 命名\n类名使用小写字母，以中划线分隔\nid 采用驼峰式命名\nscss 中的变量、函数、混合、placeholder 采用驼峰式命名\n\nID 和 class 的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称\n不推荐：\n.fw-800 &#123;\n  font-weight: 800;\n&#125;\n\n.red &#123;\n  color: red;\n&#125;\n\n推荐:\n.heavy &#123;\n  font-weight: 800;\n&#125;\n\n.important &#123;\n  color: red;\n&#125;\n\n1.3.2 选择器\nCSS 选择器中避免使用标签名从结构、表现、行为分离的原则来看，应该尽量避免 CSS 中出现 HTML 标签，并且在 CSS 选择器中出现标签名会存在潜在的问题。\n\n很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到 DOM 末端的选择器， 你应该总是考虑直接子选择器。\n\n\n不推荐:\n.content .title &#123;\n  font-size: 2rem;\n&#125;\n\n推荐:\n.content &gt; .title &#123;\n  font-size: 2rem;\n&#125;\n\n1.3.3 尽量使用缩写属性不推荐：\nborder-top-style: none;\nfont-family: palatino, georgia, serif;\nfont-size: 100%;\nline-height: 1.6;\npadding-bottom: 2em;\npadding-left: 1em;\npadding-right: 1em;\npadding-top: 0;\n\n推荐：\nborder-top: 0;\nfont: 100%&#x2F;1.6 palatino, georgia, serif;\npadding: 0 1em 2em;\n\n1.3.4 每个选择器及属性独占一行不推荐：\nbutton &#123;\n  width: 100px;\n  height: 50px;\n  color: #fff;\n  background: #00a0e9;\n&#125;\n\n推荐：\nbutton &#123;\n  width: 100px;\n  height: 50px;\n  color: #fff;\n  background: #00a0e9;\n&#125;\n\n1.3.5 省略 0 后面的单位不推荐：\ndiv &#123;\n  padding-bottom: 0px;\n  margin: 0em;\n&#125;\n\n推荐：\ndiv &#123;\n  padding-bottom: 0;\n  margin: 0;\n&#125;\n\n1.3.6 避免使用 ID 选择器及全局标签选择器防止污染全局样式不推荐：\n#header &#123;\n  padding-bottom: 0;\n  margin: 0;\n&#125;\n\n推荐：\n.header &#123;\n  padding-bottom: 0;\n  margin: 0;\n&#125;\n\n(四) SCSS 规范1.4.1 代码组织1) 将公共 scss 文件放置在 src/assets/styles 文件夹例：variables.scss / mixin.scss\n2) 按以下顺序组织\n@import\n变量声明\n样式声明\n\n@import &#39;mixins&#x2F;size.less&#39;;\n\n@default-text-color: #333;\n\n.page &#123;\n  width: 960px;\n  margin: 0 auto;\n&#125;\n\n1.4.2 避免嵌套层级过多将嵌套深度限制在 3 级。对于超过 4 级的嵌套，给予重新评估。这可以避免出现过于详实的 CSS 选择器。避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于 20 行的嵌套规则出现\n不推荐：\n.main &#123;\n  .title &#123;\n    .name &#123;\n      color: #fff;\n    &#125;\n  &#125;\n&#125;\n\n推荐：\n.main-title &#123;\n  .name &#123;\n    color: #fff;\n  &#125;\n&#125;\n\n(五) Javascript 规范1.5.1 命名1) 采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束反例： _name / name_ / name$\n2) 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。正例： localValue / getHttpMessage() / inputUserId\n其中 method 方法命名必须是 动词 或者 动词+名词 形式\n正例：saveShopCarData /openShopCarInfoDialog\n反例：save / open / show / go\n特此说明，增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）\nadd &#x2F; update &#x2F; delete &#x2F; detail &#x2F; get\n\n附： 函数方法常用的动词:\nget 获取&#x2F;set 设置,\nadd 增加&#x2F;remove 删除\ncreate 创建&#x2F;destory 移除\nstart 启动&#x2F;stop 停止\nopen 打开&#x2F;close 关闭,\nread 读取&#x2F;write 写入\nload 载入&#x2F;save 保存,\ncreate 创建&#x2F;destroy 销毁\nbegin 开始&#x2F;end 结束,\nbackup 备份&#x2F;restore 恢复\nimport 导入&#x2F;export 导出,\nsplit 分割&#x2F;merge 合并\ninject 注入&#x2F;extract 提取,\nattach 附着&#x2F;detach 脱离\nbind 绑定&#x2F;separate 分离,\nview 查看&#x2F;browse 浏览\nedit 编辑&#x2F;modify 修改,\nselect 选取&#x2F;mark 标记\ncopy 复制&#x2F;paste 粘贴,\nundo 撤销&#x2F;redo 重做\ninsert 插入&#x2F;delete 移除,\nadd 加入&#x2F;append 添加\nclean 清理&#x2F;clear 清除,\nindex 索引&#x2F;sort 排序\nfind 查找&#x2F;search 搜索,\nincrease 增加&#x2F;decrease 减少\nplay 播放&#x2F;pause 暂停,\nlaunch 启动&#x2F;run 运行\ncompile 编译&#x2F;execute 执行,\ndebug 调试&#x2F;trace 跟踪\nobserve 观察&#x2F;listen 监听,\nbuild 构建&#x2F;publish 发布\ninput 输入&#x2F;output 输出,\nencode 编码&#x2F;decode 解码\nencrypt 加密&#x2F;decrypt 解密,\ncompress 压缩&#x2F;decompress 解压缩\npack 打包&#x2F;unpack 解包,\nparse 解析&#x2F;emit 生成\nconnect 连接&#x2F;disconnect 断开,\nsend 发送&#x2F;receive 接收\ndownload 下载&#x2F;upload 上传,\nrefresh 刷新&#x2F;synchronize 同步\nupdate 更新&#x2F;revert 复原,\nlock 锁定&#x2F;unlock 解锁\ncheck out 签出&#x2F;check in 签入,\nsubmit 提交&#x2F;commit 交付\npush 推&#x2F;pull 拉,\nexpand 展开&#x2F;collapse 折叠\nbegin 起始&#x2F;end 结束,\nstart 开始&#x2F;finish 完成\nenter 进入&#x2F;exit 退出,\nabort 放弃&#x2F;quit 离开\nobsolete 废弃&#x2F;depreciate 废旧,\ncollect 收集&#x2F;aggregate 聚集\n\n3) 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。正例： MAX_STOCK_COUNT\n反例： MAX_COUNT\n1.5.2 代码格式1) 使用 2 个空格进行缩进正例：\nif (x &lt; y) &#123;\n  x +&#x3D; 10\n&#125; else &#123;\n  x +&#x3D; 1\n&#125;\n\n2) 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。\n\n\n\n\n\n\n\n\n说明：任何情形，没有必要插入多个空行进行隔开。\n1.5.3 字符串1) 统一使用单引号(‘)，不使用双引号(“)。这在创建 HTML 字符串非常有好处：正例：\nlet str &#x3D; &#39;foo&#39;\nlet testDiv &#x3D; &#39;&lt;div id&#x3D;&quot;test&quot;&gt;&lt;&#x2F;div&gt;&#39;\n\n反例：\nlet str &#x3D; &#39;foo&#39;\nlet testDiv &#x3D; &quot;&lt;div id&#x3D;&#39;test&#39;&gt;&lt;&#x2F;div&gt;&quot;\n\n2) 字符串拼接统一使用 ES6 模板字符串处理正例：\nconst firstName &#x3D; &#39;Tom&#39;\nconst lastName &#x3D; &#39;Hanks&#39;\nconst fullName &#x3D; &#96;$&#123;firstName&#125; $&#123;lastName&#125;&#96;\n\n反例：\nconst firstName &#x3D; &#39;Tom&#39;\nconst lastName &#x3D; &#39;Hanks&#39;\nconst fullName &#x3D; firstName + &#39; &#39; + lastName\n\n1.5.4 对象声明1) 使用字面值创建对象正例： let user = &#123;&#125;;\n反例： let user = new Object();\n2) 使用字面量来代替对象构造器正例：\nconst user &#x3D; &#123;\n  age: 0,\n  name: 1,\n  city: 3\n&#125;\n\n反例：\nconst user &#x3D; new Object()\nuser.age &#x3D; 0\nuser.name &#x3D; 0\nuser.city &#x3D; 0\n\n1.5.5 使用 ES6,ES7必须优先使用 ES6,ES7 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。\n\n\n\n\n\n\n\n\n\n必须强制使用 ES6, ES7 的新语法，比如箭头函数、await/async，解构，let，for…of 等等\n1.5.6 括号下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。\n正例：\nif (condition) &#123;\n  doSomething()\n&#125;\n\n反例：\nif (condition) doSomething()\n\n1.5.7 undefined 判断永远不要直接使用 undefined 进行变量判断；使用 typeof 和字符串 &#39;undefined&#39; 对变量进行判断。\nif (typeof person &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;\n    ...\n&#125;\n\n反例：1\n&#x2F;&#x2F; person 为 null 也是 true\nif (person &#x3D;&#x3D; undefined) &#123;\n    ...\n&#125;\n\n反例：2 MDN 也有说明\nif (person &#x3D;&#x3D;&#x3D; undefined) &#123;\n    ...\n&#125;\n\n&#x2F;&#x2F; JavaScript 设计问题， undefined 可以全局作用域中被当作标识符（变量名）来使用\n&#x2F;&#x2F; 因为 undefined 不是一个保留字\n&#x2F;&#x2F; 不要这样做！\n\n&#x2F;&#x2F; 打印 &#39;foo string&#39; PS：说明undefined的值和类型都已经改变\n(function() &#123;\nvar undefined &#x3D; &#39;foo&#39;;\nconsole.log(undefined, typeof undefined)\n&#125;)()\n\n&#x2F;&#x2F; 打印 &#39;foo string&#39; PS：说明undefined的值和类型都已经改变\n(function(undefined) &#123;\nconsole.log(undefined, typeof undefined)\n&#125;)(&#39;foo&#39;)\n\n1.5.8 条件判断和循环最多三层条件判断能使用三目运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三目运算符。如果超过 3 层请抽成函数，并写清楚注释。\n1.5.9 this 的转换命名对上下文 this 的引用只能使用 self 来命名\n1.5.10 慎用 console.log因 console.log 大量使用会有性能问题，所以在非 webpack 项目中谨慎使用 log 功能\n二、Vue 项目规范(一) Vue 编码基础二、Vue 项目规范以 Vue 官方规范 （https://cn.vuejs.org/v2/style-guide/） 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。\n\n\n\n\n\n\n\n\n\n请仔仔细细阅读 Vue 官方规范，切记，此为第一步。\n2.1.1. 组件规范1) 组件名为多个单词。组件名应该始终是多个单词组成（大于等于 2），且命名规范为 CamelCase 格式。这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。\n正例：\nexport default &#123;\n  name: &#39;TodoItem&#39;\n  &#x2F;&#x2F; ...\n&#125;\n\n反例：\nexport default &#123;\n  name: &#39;todo&#39;\n  &#x2F;&#x2F; ...\n&#125;\nexport default &#123;\n  name: &#39;todo-item&#39;\n  &#x2F;&#x2F; ...\n&#125;\n\n2) 组件文件名为 CamelCase 格式正例：\ncomponents&#x2F;\n|- MyComponent.vue\n\n反例：\ncomponents&#x2F;\n|- myComponent.vue\n|- my-component.vue\n\n3) 基础组件文件名为 base 开头，使用完整单词而不是缩写。正例：\ncomponents&#x2F;\n|- BaseButton.vue\n|- BaseTable.vue\n|- BaseIcon.vue\n\n反例：\ncomponents&#x2F;\n|- MyButton.vue\n|- VueTable.vue\n|- Icon.vue\n\n4) 和父组件紧密耦合的子组件应该以父组件名作为前缀命名正例：\ncomponents&#x2F;\n|- TodoList.vue\n|- TodoListItem.vue\n|- TodoListItemNutton.vue\n|- UserProfileOptions.vue （完整单词）\n\n反例：\ncomponents&#x2F;\n|- TodoList.vue\n|- TodoItem.vue\n|- TodoButton.vue\n|- UProfOpts.vue （使用了缩写）\n\n5) 在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件。正例：\n&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;\n&lt;my-component &#x2F;&gt;\n&lt;row&gt;&lt;table :column&#x3D;&quot;data&quot; &#x2F;&gt;&lt;&#x2F;row&gt;\n\n反例：\n&lt;MyComponent &#x2F;&gt; &lt;Row&gt;&lt;table :column&#x3D;&quot;data&quot; &#x2F;&gt;&lt;&#x2F;Row&gt;\n\n6) 组件的 data 必须是一个函数当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。\n正例：\nexport default &#123;\n  data() &#123;\n    return &#123;\n      name: &#39;jack&#39;\n    &#125;\n  &#125;\n&#125;\n\n反例：\nexport default &#123;\n  data: &#123;\n    name: &#39;jack&#39;\n  &#125;\n&#125;\n\n7) Prop 定义应该尽量详细\n必须使用 camelCase 驼峰命名\n必须指定类型\n如果变量名不能表达其含义，必须加上注释，表明其含义\n必须加上 required 或者 default，两者二选其一\n如果有业务需要，必须加上 validator 验证\n\n正例：\n props: &#123;\n  &#x2F;&#x2F; 组件状态，用于控制组件的颜色\n   status: &#123;\n     type: String,\n     required: true,\n     validator: function (value) &#123;\n       return [\n         &#39;succ&#39;,\n         &#39;info&#39;,\n         &#39;error&#39;\n       ].indexOf(value) !&#x3D;&#x3D; -1\n     &#125;\n   &#125;,\n    &#x2F;&#x2F; 用户级别，用于显示皇冠个数\n   userLevel：&#123;\n      type: String,\n      required: true\n   &#125;\n&#125;\n\n8) 为组件样式设置作用域正例：\n&lt;template&gt;\n  &lt;button class&#x3D;&quot;btn btn-close&quot;&gt;X&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n\n&lt;!-- 使用 &#96;scoped&#96; 特性 --&gt;\n&lt;style scoped&gt;\n.btn-close &#123;\n  background-color: red;\n&#125;\n&lt;&#x2F;style&gt;\n\n反例：\n&lt;template&gt;\n  &lt;button class&#x3D;&quot;btn btn-close&quot;&gt;X&lt;&#x2F;button&gt;\n&lt;&#x2F;template&gt;\n&lt;!-- 没有使用 &#96;scoped&#96; 特性 --&gt;\n&lt;style&gt;\n.btn-close &#123;\n  background-color: red;\n&#125;\n&lt;&#x2F;style&gt;\n\n9) 如果特性元素较多，应该主动换行。正例：\n&lt;ym-table :isLoading&#x3D;&quot;isTableLoading&quot; :tableData&#x3D;&quot;tableData&quot; :pageTotal&#x3D;&quot;pageTotal&quot; :pageNum&#x3D;&quot;pageNum&quot; :pageSize&#x3D;&quot;pageSize&quot; @page-num-change&#x3D;&quot;handlePageNumChange&quot; @page-size-change&#x3D;&quot;handlePageSizeChange&quot; &#x2F;&gt;\n\n反例：\n&lt;ym-table :isLoading&#x3D;&quot;isTableLoading&quot; :tableData&#x3D;&quot;tableData&quot; :pageTotal&#x3D;&quot;pageTotal&quot; :pageNum&#x3D;&quot;pageNum&quot; :pageSize&#x3D;&quot;pageSize&quot; @page-num-change&#x3D;&quot;handlePageNumChange&quot; @page-size-change&#x3D;&quot;handlePageSizeChange&quot; &#x2F;&gt;\n\n2.1.2. 模板中使用简单的表达式组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。\n正例：\n&lt;template&gt;\n  &lt;p&gt;&#123;&#123; normalizedFullName &#125;&#125;&lt;&#x2F;p&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\n&#x2F;&#x2F; 复杂表达式已经移入一个计算属性\ncomputed: &#123;\n  normalizedFullName: function () &#123;\n    return this.fullName.split(&#39; &#39;).map(function (word) &#123;\n      return word[0].toUpperCase() + word.slice(1)\n    &#125;).join(&#39; &#39;)\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n反例：\n&lt;template&gt;\n  &lt;p&gt;\n    &#123;&#123;\n      fullName\n        .split(&#39; &#39;)\n        .map(function (word) &#123;\n          return word[0].toUpperCase() + word.slice(1)\n        &#125;)\n        .join(&#39; &#39;)\n    &#125;&#125;\n  &lt;&#x2F;p&gt;\n&lt;&#x2F;template&gt;\n\n2.1.3 指令都使用缩写形式指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)\n正例：\n&lt;input :text&#x3D;&quot;text&quot; @change&#x3D;&quot;onChange&quot; &#x2F;&gt;\n\n反例：\n&lt;input v-bind:text&#x3D;&quot;text&quot; v-on:change&#x3D;&quot;onChange&quot; &#x2F;&gt;\n\n2.1.4 标签顺序保持一致单文件组件应该总是让标签顺序保持为 `\n正例：\n&lt;template&gt;...&lt;&#x2F;template&gt;\n&lt;script&gt;\n...\n&lt;&#x2F;script&gt;\n&lt;style&gt;\n...;\n&lt;&#x2F;style&gt;\n\n反例：\n&lt;template&gt;...&lt;&#x2F;template&gt;\n&lt;style&gt;\n...\n&lt;&#x2F;style&gt;\n&lt;script&gt;\n...\n&lt;&#x2F;script&gt;\n\n2.1.5 必须为 v-for 设置键值 key2.1.6 v-show 与 v-if 选择如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。\n2.1.7 script 标签内部结构顺序components &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数（钩子函数按其执行顺序） &gt; methods\n2.1.8 Vue Router 规范1) 页面跳转数据传递使用路由参数页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。\n正例：\nlet id &#x3D; &#39; 123&#39;;\nthis.$router.push(&#123; name: &#39;userCenter&#39;, query: &#123; id: id &#125; &#125;);\n\n2) 使用路由懒加载（延迟加载）机制&#123;\n    path: &#39;&#x2F;uploadAttachment&#39;,\n    name: &#39;uploadAttachment&#39;,\n    meta: &#123;\n      title: &#39;上传附件&#39;\n    &#125;,\n    component: () &#x3D;&gt; import(&#39;@&#x2F;view&#x2F;components&#x2F;uploadAttachment&#x2F;index.vue&#39;)\n  &#125;,\n\n3) router 中的命名规范path、childrenPoints 命名规范采用 kebab-case 命名规范（尽量 Vue 文件的目录结构保持一致，因为目录、文件名都是 kebab-case，这样很方便找到对应的文件）\nname 命名规范采用 KebabCase 命名规范且和 component 组件名保持一致！（因为要保持 keep-alive 特性，keep-alive 按照 component 的 name 进行缓存，所以两者必须高度保持一致）\nJavaScript\n&#x2F;&#x2F; 动态加载\nexport const reload &#x3D; [\n  &#123;\n    path: &#39;&#x2F;reload&#39;,\n    name: &#39;reload&#39;,\n    component: Main,\n    meta: &#123;\n      title: &#39;动态加载&#39;,\n      icon: &#39;icon iconfont&#39;\n    &#125;,\n\n    children: [\n      &#123;\n        path: &#39;&#x2F;reload&#x2F;smart-reload-list&#39;,\n        name: &#39;SmartReloadList&#39;,\n        meta: &#123;\n          title: &#39;SmartReload&#39;,\n          childrenPoints: [\n            &#123;\n              title: &#39;查询&#39;,\n              name: &#39;smart-reload-search&#39;\n            &#125;,\n            &#123;\n              title: &#39;执行reload&#39;,\n              name: &#39;smart-reload-update&#39;\n            &#125;,\n            &#123;\n              title: &#39;查看执行结果&#39;,\n              name: &#39;smart-reload-result&#39;\n            &#125;\n          ]\n        &#125;,\n        component: () &#x3D;&gt;\n          import(&#39;@&#x2F;views&#x2F;reload&#x2F;smart-reload&#x2F;smart-reload-list.vue&#39;)\n      &#125;\n    ]\n  &#125;\n];\n\n4) router 中的 path 命名规范path 除了采用 kebab-case 命名规范以外，必须以 / 开头，即使是 children 里的 path 也要以 / 开头。如下示例\n目的：\n经常有这样的场景：某个页面有问题，要立刻找到这个 vue 文件，如果不用以/开头，path 为 parent 和 children 组成的，可能经常需要在 router 文件里搜索多次才能找到，而如果以 / 开头，则能立刻搜索到对应的组件\nJavaScript\n&#123;\n    path: &#39;&#x2F;file&#39;,\n    name: &#39;File&#39;,\n    component: Main,\n    meta: &#123;\n      title: &#39;文件服务&#39;,\n      icon: &#39;ios-cloud-upload&#39;\n    &#125;,\n    children: [\n      &#123;\n        path: &#39;&#x2F;file&#x2F;file-list&#39;,\n        name: &#39;FileList&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;file&#x2F;file-list.vue&#39;)\n      &#125;,\n      &#123;\n        path: &#39;&#x2F;file&#x2F;file-add&#39;,\n        name: &#39;FileAdd&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;file&#x2F;file-add.vue&#39;)\n      &#125;,\n      &#123;\n        path: &#39;&#x2F;file&#x2F;file-update&#39;,\n        name: &#39;FileUpdate&#39;,\n        component: () &#x3D;&gt; import(&#39;@&#x2F;views&#x2F;file&#x2F;file-update.vue&#39;)\n      &#125;\n    ]\n  &#125;\n\n(二) Vue 项目目录规范2.2.1 基础vue 项目中的所有命名一定要与后端命名统一。\n比如权限：后端 privilege, 前端无论 router , store, api 等都必须使用 privielege 单词！\n2.2.2 使用 Vue-cli 脚手架使用 vue-cli3 来初始化项目，项目名按照上面的命名规范。\n2.2.3 目录说明目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名。\n├── build                      &#x2F;&#x2F; 构建相关\n├── bin                        &#x2F;&#x2F; 执行脚本\n├── public                     &#x2F;&#x2F; 公共文件\n│   ├── favicon.ico            &#x2F;&#x2F; favicon图标\n│   └── index.html             &#x2F;&#x2F; html模板\n├── src                        &#x2F;&#x2F; 源代码\n│   ├── api                    &#x2F;&#x2F; 所有请求\n│   ├── assets                 &#x2F;&#x2F; 主题 字体等静态资源\n│   ├── components             &#x2F;&#x2F; 全局公用组件\n│   ├── directive              &#x2F;&#x2F; 全局指令\n│   ├── layout                 &#x2F;&#x2F; 布局\n│   ├── router                 &#x2F;&#x2F; 路由\n│   ├── store                  &#x2F;&#x2F; 全局状态管理(Vuex)\n│   ├── utils                  &#x2F;&#x2F; 全局公用方法\n│   ├── views                  &#x2F;&#x2F; 页面\n│   ├── App.vue                &#x2F;&#x2F; 入口页面\n│   ├── main.js                &#x2F;&#x2F; 入口 加载组件 初始化等\n│   ├── permission.js          &#x2F;&#x2F; 权限管理\n│   └── settings.js            &#x2F;&#x2F; 系统配置\n├── .editorconfig              &#x2F;&#x2F; 编码格式\n├── .env.development           &#x2F;&#x2F; 开发环境配置\n├── .env.production            &#x2F;&#x2F; 生产环境配置\n├── .env.staging               &#x2F;&#x2F; 测试环境配置\n├── .eslintignore              &#x2F;&#x2F; 忽略语法检查\n├── .eslintrc.js               &#x2F;&#x2F; eslint 配置项\n├── .prettierrc                &#x2F;&#x2F; 代码格式化配置\n├── jsconfig.json              &#x2F;&#x2F; 指定了根文件和 JavaScript 语言服务提供的特性的选项\n├── .gitignore                 &#x2F;&#x2F; git 忽略项\n├── babel.config.js            &#x2F;&#x2F; babel.config.js\n├── package.json               &#x2F;&#x2F; package.json\n└── vue.config.js              &#x2F;&#x2F; Vue 项目配置\n\n1) api 目录\n文件、变量命名尽量与后端保持一致。\n此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。\napi 中的方法名字要与后端 api url 尽量保持语义高度一致性。\napi 中的每个方法要添加注释，注释与后端 swagger 文档保持一致。\napi 中的每个方法的参数尽量定义完全，便于调用时参数的查看。\n\n正例：\n后端 ： EmployeeController.java\n&#x2F;employee&#x2F;add\n&#x2F;employee&#x2F;delete&#x2F;&#123;id&#125;\n&#x2F;employee&#x2F;update\n\n前端： employee.js\n&#x2F;&#x2F; 添加员工\nexport const addEmployee &#x3D; (username, age, gender) &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;employee&#x2F;add&#39;,\n    method: &#39;post&#39;,\n    data: &#123;\n      username,\n      age,\n      gender\n    &#125;\n  &#125;)\n&#125;\n&#x2F;&#x2F; 更新员工信息\nexport const updateEmployee &#x3D; (username, age, gender) &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#39;&#x2F;employee&#x2F;update&#39;,\n    method: &#39;post&#39;,\n    data: &#123;\n      username,\n      age,\n      gender\n    &#125;\n  &#125;)\n&#125;\n&#x2F;&#x2F; 删除员工\nexport const deleteEmployee &#x3D; (employeeId) &#x3D;&gt; &#123;\n  return request(&#123;\n    url: &#96;&#x2F;employee&#x2F;delete&#x2F;$&#123;employeeId&#125;&#96;,\n    method: &#39;post&#39;\n  &#125;)\n&#125;\n\n2) assets 目录assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 kebab-case\n|assets\n|-- icons\n|-- images\n|   |-- background-color.png\n|   |-- upload-header.png\n|-- styles\n\n3) components 目录此目录应按照组件进行目录划分，目录命名为 CamelCase，组件命名规则也为 CamelCase\n|components\n|-- ErrorLog\n|   |-- index.vue\n|   |-- index.scss\n|-- MarkdownEditor\n|   |-- index.vue\n|   |-- index.scss\n\n4) constants 目录此目录存放项目所有常量，如果常量在 vue 中使用，请使用 vue-enum 插件(https://www.npmjs.com/package/vue-enum)\n目录结构：\n|constants\n|-- index.js\n|-- role.js\n|-- employee.js\n\n例子： employee.js\nexport const EMPLOYEE_STATUS &#x3D; &#123;\n  NORMAL: &#123;\n    value: 1,\n    desc: &#39;正常&#39;\n  &#125;,\n  DISABLED: &#123;\n    value: 1,\n    desc: &#39;禁用&#39;\n  &#125;,\n  DELETED: &#123;\n    value: 2,\n    desc: &#39;已删除&#39;\n  &#125;\n&#125;\n\nexport const EMPLOYEE_ACCOUNT_TYPE &#x3D; &#123;\n  QQ: &#123;\n    value: 1,\n    desc: &#39;QQ登录&#39;\n  &#125;,\n  WECHAT: &#123;\n    value: 2,\n    desc: &#39;微信登录&#39;\n  &#125;,\n  DINGDING: &#123;\n    value: 3,\n    desc: &#39;钉钉登录&#39;\n  &#125;,\n  USERNAME: &#123;\n    value: 4,\n    desc: &#39;用户名密码登录&#39;\n  &#125;\n&#125;\n\nexport default &#123;\n  EMPLOYEE_STATUS,\n  EMPLOYEE_ACCOUNT_TYPE\n&#125;\n\n5) router 与 store 目录这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。\nrouter 尽量按照 views 中的结构保持一致\nstore 按照业务进行拆分不同的 js 文件\n6) views 目录\n命名要与后端、router、api 等保持一致\ncomponents 中组件要使用 CamelCase 规则\nindex.vue除外\n\n|-- views                            视图目录\n|   |-- Role                             role模块名\n|   |   |-- RoleList.vue                    role列表页面\n|   |   |-- RoleAdd.vue                     role新建页面\n|   |   |-- RoleUpdate.vue                  role更新页面\n|   |   |-- index.vue                      role模块样式\n|   |-- Employee                         employee模块\n|   |-- BehaviorLog                      行为日志log模块\n|   |-- CodeGenerator                    代码生成器模块\n\n2.2.4 注释说明\n在变量名和函数名不足以表达其含义时才需要注释\n公共组件需要注释\nstore 中的 state, mutation, action 等需要注释\n函数的逻辑特别复杂时需要注释\n\n2.2.5 其他1) 尽量不要手动操作 DOM因使用 Vue 框架，所以在项目开发中尽量使用 Vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 Dom 元素、以及更改样式、添加事件等。\n2) 删除无用代码因使用了 Git 代码版本工具，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。\n","slug":"前端开发规范","date":"2021-01-25T10:31:16.000Z","categories_index":"前端","tags_index":"规范","author_index":"ZV"},{"id":"b88101b328f136c8f25d5c4f4b2521da","title":"一网打尽this","content":"例题组合 1：全局环境下的 thisfunction f1() &#123;\n  console.log(this)\n&#125;\nfunction f2() &#123;\n  &#39;use strict&#39;\n  console.log(this)\n&#125;\nf1() &#x2F;&#x2F; window\nf2() &#x2F;&#x2F; undefined\n\nconst foo &#x3D; &#123;\n  bar: 10,\n  fn: function () &#123;\n    console.log(this)\n    console.log(this.bar)\n  &#125;\n&#125;\nvar fn1 &#x3D; foo.fn &#x2F;&#x2F; 相当于 window.fn1 &#x3D; foo.fn\nfn1() &#x2F;&#x2F; window undefined\n\nconst foo &#x3D; &#123;\n  bar: 10,\n  fn: function () &#123;\n    console.log(this)\n    console.log(this.bar)\n  &#125;\n&#125;\nfoo.fn() &#x2F;&#x2F; foo 10\n\n\n\n\n\n\n\n\n\n\n结论：在执行函数时，如果函数中的 this 是被上一级的对象所调用，那么 this 指向的就是上一级的对象；否则指向全局环境。\n例题组合 2：上下文对象调用中的 thisconst person &#x3D; &#123;\n  name: &#39;Lucas&#39;,\n  brother: &#123;\n    name: &#39;Mike&#39;,\n    fn: function () &#123;\n      return this.name\n    &#125;\n  &#125;\n&#125;\nconsole.log(person.brother.fn()) &#x2F;&#x2F; &#39;Mike&#39;\n&#x2F;&#x2F; 在这种嵌套的关系中，this 指向最后调用它的对象，因此输出将会是：Mike。\n\nconst o1 &#x3D; &#123;\n  text: &#39;o1&#39;,\n  fn: function () &#123;\n    return this.text\n  &#125;\n&#125;\nconst o2 &#x3D; &#123;\n  text: &#39;o2&#39;,\n  fn: function () &#123;\n    return o1.fn()\n  &#125;\n&#125;\nconst o3 &#x3D; &#123;\n  text: &#39;o3&#39;,\n  fn: function () &#123;\n    var fn &#x3D; o1.fn\n    return fn()\n  &#125;\n&#125;\nconst o4 &#x3D; &#123;\n  text: &#39;o4&#39;,\n  fn: o1.fn\n&#125;\n\nconsole.log(o1.fn()) &#x2F;&#x2F; o1\nconsole.log(o2.fn()) &#x2F;&#x2F; o1\nconsole.log(o3.fn()) &#x2F;&#x2F; undefined\nconsole.log(o4.fn()) &#x2F;&#x2F; 04\n&#x2F;* \n  第一个 console 最简单，o1 没有问题。难点在第二个和第三个上面，关键还是看调用 this 的那个函数。 \n  第二个 console 的 o2.fn()，最终还是调用 o1.fn()，因此答案仍然是 o1。 \n  第三个，在进行 var fn &#x3D; o1.fn 赋值之后，是「裸奔」调用，因此这里的 this 指向 window，答案当然是 undefined。\n  第四个，this 指向最后调用它的对象，在 fn 执行时，挂到 o4 对象上即可，我们提前进行了赋值操作\n*&#x2F;\n\n例题组合 3：bind/call/apply 改变 this 指向&#x2F;&#x2F; 三者使用区别\nconst printName &#x3D; (firstName, lastName) &#x3D;&gt; console.log(&#96;$&#123;firstName&#125; $&#123;lastName&#125;&#96;)\n&#x2F;&#x2F; bind\nprintName.bind(null, &#39;Number&#39;, &#39;One&#39;)() &#x2F;&#x2F; 常见于 React 绑定事件\n&#x2F;&#x2F; call\nprintName.call(null, &#39;Number&#39;, &#39;Two&#39;)\n&#x2F;&#x2F; apply\nprintName.apply(null, [&#39;Number&#39;, &#39;Three&#39;])\n\nconst foo &#x3D; &#123;\n  name: &#39;lucas&#39;,\n  logName: function () &#123;\n    return this.name\n  &#125;\n&#125;\n\nconst bar &#x3D; &#123;\n  name: &#39;mike&#39;\n&#125;\nconsole.log(foo.logName.bind(bar)()) &#x2F;&#x2F; mike\nconsole.log(foo.logName.call(bar)) &#x2F;&#x2F; mike\nconsole.log(foo.logName.apply(bar)) &#x2F;&#x2F; mike\n\n例题组合 4：构造函数和 thisfunction Foo() &#123;\n  this.bar &#x3D; &#39;Lucas&#39;\n&#125;\nconst instance &#x3D; new Foo()\nconsole.log(instance.bar)\n&#x2F;* \n  new 操作符调用构造函数，具体做了什么？以下供参考： \n  1.创建一个新的对象； \n  2.将构造函数的 this 指向这个新对象； \n  3.为这个对象添加属性、方法等； \n  4.最终返回新对象。\n\n  以上过程，也可以用代码表述：\n  var obj  &#x3D; &#123;&#125;\n  obj.__proto__ &#x3D; Foo.prototype\n  Foo.call(obj)\n*&#x2F;\n\nfunction Foo() &#123;\n  this.user &#x3D; &#39;Lucas&#39;\n  const o &#x3D; &#123;&#125;\n  return o\n&#125;\nfunction Bar() &#123;\n  this.user &#x3D; &#39;Lucas&#39;\n  return 1\n&#125;\nconsole.log(new Foo()) &#x2F;&#x2F; &#123;&#125;\nconsole.log(new Bar()) &#x2F;&#x2F; Bar &#123;user: &quot;Lucas&quot;&#125;\n&#x2F;* \n  结论：如果构造函数中显式返回一个值，且返回的是一个对象，那么 this 就指向这个返回的对象；\n  如果返回的不是一个对象，那么 this 仍然指向实例。\n*&#x2F;\n\n例题组合 5：箭头函数中的 this 指向const foo &#x3D; &#123;\n  fn: function () &#123;\n    setTimeout(function () &#123;\n      console.log(this)\n    &#125;)\n  &#125;\n&#125;\nconst bar &#x3D; &#123;\n  fn: function () &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(this)\n    &#125;)\n  &#125;\n&#125;\n\nconsole.log(foo.fn()) &#x2F;&#x2F; window\nconsole.log(bar.fn()) &#x2F;&#x2F; &#123;fn: ƒ&#125;\n&#x2F;* \n  this 出现在 setTimeout() 中的匿名函数里，因此 this 指向 window 对象。\n  如果需要 this 指向 foo这个 object 对象，可以巧用箭头函数解决： \n*&#x2F;\n\n最后一道const bar &#x3D; &#123;\n  f1: function () &#123;\n    console.log(this)\n  &#125;,\n  f2: () &#x3D;&gt; &#123;\n    console.log(this)\n  &#125;,\n  f3: function () &#123;\n    const fun &#x3D; () &#x3D;&gt; &#123;\n      console.log(this)\n    &#125;\n    fun()\n  &#125;,\n  f4: () &#x3D;&gt; &#123;\n    function fun() &#123;\n      console.log(this)\n    &#125;\n    fun()\n  &#125;\n&#125;\n\nbar.f1() &#x2F;&#x2F; bar | f1 被 bar 调用，所以打印的 this 是 bar\nbar.f2() &#x2F;&#x2F; window | f2 的 this 是 f2 外层的 bar 的 this，所以打印的 this 是 window\nbar.f3() &#x2F;&#x2F; bar | f3 中 fun 的 this 是 fun 外层的 f3 的 this， f3 被 bar 调用，f3 的 this 是 bar，所以打印的 this 是 window\nbar.f4() &#x2F;&#x2F; f4 中的 fun 的执行属于普通函数调用，只是自执行，此时 fun 是一个全局函数，因此打印的 this 是 window\n\nconst f1 &#x3D; bar.f1\nf1() &#x2F;&#x2F; window\nconst f2 &#x3D; bar.f2\nf2() &#x2F;&#x2F; window\nconst f3 &#x3D; bar.f3\nf3() &#x2F;&#x2F; window\nconst f4 &#x3D; bar.f4\nf4() &#x2F;&#x2F; window\n","slug":"一网打尽this","date":"2021-01-24T21:06:53.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"ZV"},{"id":"594852812e8442355d6909ab675fc295","title":"Learning-The-Shell","content":"01 - What Is the shell 什么是脚本\n\n\n命令\nEN\nZH\n\n\n\ndate\nDisplays the current time and date.\n显示当前日期\n\n\ncal\nDisplays a calendar of thecurrent month.\n显示日历\n\n\ndf\nDisk free\n剩余磁盘\n\n\nfree\nDisplay the amount of free memor\n剩余内存\n\n\nexit\nEnding a Terminal Session.\n关闭一个命令行会话\n\n\n02 - Navigation 导航\n\n\n命令\nEN\nZH\n\n\n\npwd\nPrint name of current working directory.\n显示当前文件夹\n\n\ncd\nChange directory.\n切换文件夹\n\n\nls\nList directory contents.\n显示文件夹内容\n\n\n03 - Exploring the System 探索系统\n\n\n命令\nEN\nZH\n\n\n\nls\nList directory contents.\n显示文件夹内容\n\n\nfile\nDetermining a File’s Type\n查看文件类型\n\n\nless\nViewing File Contents\n查看文件内容\n\n\n04 - Manipulating Files and Directories 操作文件和目录\n\n\n命令\nEN\nZH\n\n\n\ncp\nCopy files and directories\n拷贝文件和文件夹\n\n\nmv\nMove/rename files and directories\n移动/重命名文件和文件夹\n\n\nmkdir\nCreate directories\n创建文件夹\n\n\nrm\nRemove files and directories\n删除文件和文件夹\n\n\nln\nCreate hard and symbolic links\n创建硬链接和符号链接\n\n\ncp - Copy Files and Directories\n\n\n命令\n结果\n\n\n\ncp file1 file2\n把 file1 拷贝到 file2 . 如果 file2 存在， 那么 file2 的内容被 file1 的内容覆盖 . 如果 file2 不存在，那么 创建 file2 ，并把 file1 的内容拷贝到 file2。\n\n\ncp -i file1 file2\n与上一条命令相似，不同的是如果 file2 存在，那么 file2 被覆盖前会提示用户。\n\n\ncp file1 file2 dir1\n把 file1 和 file2 拷贝进 dir1，前提是 dir1 一定要存在。\n\n\ncp dir1/* dir2\n使用通配符，把 dir1 的内容都拷贝进 dir 中，前提是 dir2 一定要存在。\n\n\ncp -r dir1 dir2\n把 dir1 的内容拷贝进 dir2 ，如果 dir2 不存在，就新建 dir2，并把 dir1 的内容拷贝进 dir2 .如果 dir2 存在就把 dir1 这个文件夹整个拷贝进 dir2，成为 dir2 的子文件夹。\n\n\n\n\n\n\n\n\n\n\n\n-i 代表 interactive交互的（会有提示问你要不要这样做）\n-r 代表 recursive递归的（递归地复制目录及其内容）\nmv - Move and Rename Files\n\n\n命令\n结果\n\n\n\nmv file1 file2\n把 file1 移动到 file2 .。如果 file2 存在， 那么 file2 的内容被 file1 的内容覆盖 .。如果 file2 不存在，那么 创建 file2 ，并把 file1 的内容拷贝到 file2，file1 不再存在。\n\n\nmv -i file1 file2\n与上一条命令相似，不同的是如果 file2 存在，那么 file2 被覆盖前会提示用户。\n\n\nmv file1 file2 dir1\n把 file1 和 file2 移动到 dir1，前提是 dir1 一定要存在。\n\n\nmv dir1 dir2\n如果 dir2 不存在, 创建 dir2 并把 dir1 的内容移动到 dir2 并删除 dir1.。如果 dir2 存在，把 dir1 移动到 dir2，成为 dir2 的子文件夹。\n\n\nrm - Remove Files and Directories\n\n\n命令\n结果\n\n\n\nrm file1\n静默删除 file1。\n\n\nrm -i file1\n与上一条命令类似，区别是在执行删除之前会提示用户确认。\n\n\nrm -r file1 dir1\n删除 file1 和 dir1 以及 dir1 中的内容\n\n\nrm -rf file1 dir1\n与上一条命令类似，但如果 file1 或 dir1 不存在，rm 将静默继续。\n\n\n\n\n\n\n\n\n\n\n\n注意\n类 Unix 的操作系统比如 Linux 是没有撤销删除命令的。\n一旦你使用 rm 命令删除一些文件，它就不存在了。Linux 假定你很聪明并且知道你在做什么。\n要特别小心使用通配符。 请考虑下面这个经典的例子。 比方说，你想在一个目录仅删除HTML文件。 为此，请键入以下内容：\nrm *.html\n\n这是正确的，但如果你不小心在 * 和 .html 之间放置了一个空格\nrm * .html\n\nrm 命令将删除目录中的所有文件，然后抱怨没有名为.html的文件。\n这里有一个实用的提示：每当你使用带有通配符的rm命令之前（除了仔细检查你的输入！），先用ls测试通配符。 这会让你看到即将被删除的文件。 然后按向上箭头调用该命令并用rm替换ls。\nln - Create LinksHard Linksln file link\n\nSymbolic Linksln -s item link\n\n区别\n\n由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：\n\n  文件有相同的 inode 及 data block；\n  只能对已存在的文件进行创建；\n  不能交叉文件系统进行硬链接的创建；\n  不能对目录进行创建，只可对文件创建；\n  删除一个硬链接文件并不影响其他有相同 inode 号的文件。\n\n软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块。因此软链接的创建与使用没有类似硬链接的诸多限制：\n\n  软链接有自己的文件属性及权限等；\n  可对不存在的文件或目录创建软链接；\n  软链接可交叉文件系统；\n  软链接可对文件或目录创建；\n  创建软链接时，链接计数 i_nlink 不会增加；\n  删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。\n\n\n\n\n\n\n\n\n\n\n理解 Linux 的硬链接与软链接\n05 - Working With Commands 使用命令\n\n\n命令\nEN\nZH\n\n\n\ntype\nIndicate how a command name is interpreted\n显示指定命令的类型\n\n\nwhich\nDisplay which executable program will be executed\n查找并显示给定命令的绝对路径\n\n\nhelp\nGet help for shell builtins\n显示内置 shell 的帮助信息\n\n\nman\nDisplay a command’s manual page\n查看 Linux 中的指令帮助\n\n\napropos\nDisplay a list of appropriate commands\n在 whatis 数据库中查找字符串\n\n\ninfo\nDisplay a command’s info entry\nLinux 下 info 格式的帮助指令\n\n\nwhatis\nDisplay one-line manual page descriptions\n查询一个命令执行什么功能\n\n\nalias\nCreate an alias for a command\n用来设置指令的别名\n\n\n什么是命令命令可以是以下四种类型之一\n\n\n\n概念\n描述\n\n\n\n可执行程序\n就像我们在 /usr/bin这个文件夹中看到的文件一样。比如常用的 yum。\n\n\n内置 shell\nBash 支持一些叫作内置 shell 的命令。举个例子 cd就是一个内置命令。\n\n\nshell 函数\n脚本。\n\n\n别名\n通过组合其他命令构成的一个自定义命令。\n\n\n认识命令type - 显示一个命令的类型[root@golinux &#x2F;]# type yum\nyum is &#x2F;usr&#x2F;bin&#x2F;yum\n[root@golinux &#x2F;]# type type\ntype is a shell builtin\n[root@golinux &#x2F;]# type ll\nll is aliased to &#96;ls -l --color&#x3D;auto&#39;\n\nwhich - 显示可执行文件的位置有时，系统上安装了多个版本的可执行程序。 虽然这在桌面系统上并不常见，但在较大的服务器上并不罕见。 要确定给定可执行文件的确切位置，请使用which命令。\n[root@golinux &#x2F;]# which yum\n&#x2F;usr&#x2F;bin&#x2F;yum\n[root@golinux &#x2F;]# which type\n&#x2F;usr&#x2F;bin&#x2F;which: no type in (&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;root&#x2F;bin)\n[root@golinux &#x2F;]# which ll\nalias ll&#x3D;&#39;ls -l --color&#x3D;auto&#39;\n\t&#x2F;usr&#x2F;bin&#x2F;ls\n\n获取命令文档help - 显示内置 shell 的帮助信息[root@golinux &#x2F;]# help cd\ncd: cd [-L|[-P [-e]]] [dir]\n    Change the shell working directory.\n    \n    Change the current directory to DIR.  The default DIR is the value of the\n    HOME shell variable.\n    \n    The variable CDPATH defines the search path for the directory containing\n    DIR.  Alternative directory names in CDPATH are separated by a colon (:).\n    A null directory name is the same as the current directory.  If DIR begins\n    with a slash (&#x2F;), then CDPATH is not used.\n    \n    If the directory is not found, and the shell option &#96;cdable_vars&#39; is set,\n    the word is assumed to be  a variable name.  If that variable has a value,\n    its value is used for DIR.\n    \n    Options:\n        -L\tforce symbolic links to be followed\n        -P\tuse the physical directory structure without following symbolic\n    \tlinks\n        -e\tif the -P option is supplied, and the current working directory\n    \tcannot be determined successfully, exit with a non-zero status\n    \n    The default is to follow symbolic links, as if &#96;-L&#39; were specified.\n    \n    Exit Status:\n    Returns 0 if the directory is changed, and if $PWD is set successfully when\n    -P is used; non-zero otherwise.\n\n–help  - 显示可执行程序的帮助信息[root@golinux &#x2F;]# mkdir --help\nUsage: mkdir [OPTION]... DIRECTORY...\nCreate the DIRECTORY(ies), if they do not already exist.\n\nMandatory arguments to long options are mandatory for short options too.\n  -m, --mode&#x3D;MODE   set file mode (as in chmod), not a&#x3D;rwx - umask\n  -p, --parents     no error if existing, make parent directories as needed\n  -v, --verbose     print a message for each created directory\n  -Z                   set SELinux security context of each created directory\n                         to the default type\n      --context[&#x3D;CTX]  like -Z, or if CTX is specified then set the SELinux\n                         or SMACK security context to CTX\n      --help     display this help and exit\n      --version  output version information and exit\n\nGNU coreutils online help: &lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;coreutils&#x2F;&gt;\nFor complete documentation, run: info coreutils &#39;mkdir invocation&#39;\n\n\nman - 在线参考手册界面apropos - 手册页的搜索引擎（在 whatis 数据库中查找字符串）[root@golinux ~]# apropos partition\naddpart (8)          - simple wrapper around the &quot;add partition&quot; ioctl\ncfdisk (8)           - display or manipulate disk partition table\ndelpart (8)          - simple wrapper around the &quot;del partition&quot; ioctl\nfdisk (8)            - manipulate disk partition table\niostat (1)           - Report Central Processing Unit (CPU) statistics and input&#x2F;output statistics for devices and partitions.\nkpartx (8)           - Create device maps from partition tables\nos-prober (1)        - Discover bootable partitions on the local system.\nparted (8)           - a partition manipulation program\npartprobe (8)        - inform the OS of partition table changes\npartx (8)            - tell the Linux kernel about the presence and numbering of on-disk partitions\nresizepart (8)       - simple wrapper around the &quot;resize partition&quot; ioctl\nsfdisk (8)           - partition table manipulator for Linux\nsystemd-efi-boot-generator (8) - Generator for automatically mounting the EFI System Partition used by the current boot to &#x2F;boot\nsystemd-gpt-auto-generator (8) - Generator for automatically discovering and mounting root, &#x2F;home and &#x2F;srv partitions, as well as discover...\n\nwhatis - 一行描述手册页[root@golinux ~]# whatis ls\nls (1)               - list directory contents\n[root@golinux ~]# whatis yum\nyum (8)              - Yellowdog Updater Modified\n[root@golinux ~]# whatis type\ntype (1)             - bash built-in commands, see bash(1)\n\n使用 alias 创建自己的命令[root@golinux ~]# alias la&#x3D;&#39;ls -la&#39;\n[root@golinux ~]# la\ntotal 104\ndr-xr-x---.  8 root root 4096 Aug 29 17:38 .\ndr-xr-xr-x. 18 root root 4096 May 10 15:12 ..\n-rw-------   1 root root 8694 Sep  4 16:22 .bash_history\n-rw-r--r--.  1 root root   18 Dec 29  2013 .bash_logout\n-rw-r--r--.  1 root root  176 Dec 29  2013 .bash_profile\n-rw-r--r--.  1 root root  176 Sep  4 16:21 .bashrc\ndrwx------   3 root root 4096 Oct 15  2017 .cache\n-rw-r--r--.  1 root root  100 Dec 29  2013 .cshrc\ndrwxr-xr-x   7 root root 4096 Dec 21  2018 .nvm\ndrwxr-xr-x   2 root root 4096 Oct 15  2017 .pip\ndrwxr-----   3 root root 4096 Dec 21  2018 .pki\n-rw-r--r--   1 root root   64 Oct 15  2017 .pydistutils.cfg\n-rw-------   1 root root   37 Feb 16  2019 .python_history\ndrwx------   2 root root 4096 Dec 20  2018 .ssh\n-rw-r--r--.  1 root root  129 Dec 29  2013 .tcshrc\ndrwxr-xr-x   6 root root 4096 Aug 26 15:15 .vim\n-rw-------   1 root root 5324 Aug 29 17:38 .viminfo\n-rw-------   1 root root 5121 Aug 26 23:19 .viminfo.tmp\n\n06 - Redirection 重定向\n\n\n命令\nEN\nZH\n\n\n\ncat\nConcatenate files\n\n\n\nsort\nSort lines of text\n\n\n\nuniq\nReport or omit repeated lines\n\n\n\ngrep\nPrint lines matching a pattern\n\n\n\nwc\nPrint newline, word, and byte counts for each file\n\n\n\nhead\nOutput the first part of a file\n\n\n\ntail\nOutput the last part of a file\n\n\n\ntee\nRead from standard input and write to standard output and files\n\n\n\nStandard Input, Output, and Error 标准输入，输出和错误Many of the programs that we have used so far produce output of some kind. This output often consists of two types.\n\nThe program’s results; that is, the data the program is designed to produce\nStatus and error messages that tell us how the program is getting along \n\n如果我们使用ls这样的命令，我们可以在屏幕上看到它显示的结果和错误消息。保持Unix主题“一切都是文件”，像ls这样的程序实际上是将结果发送到一个名为标准输出（通常表示为stdout）的特殊文件，并将其状态消息发送到另一个名为标准错误（stderr）的文件。 默认情况下，标准输出和标准错误都会链接到屏幕上，而不是保存到磁盘文件中。此外，许多程序从名为标准输入（stdin）的工具获取输入，默认情况下，该工具连接到键盘。I / O重定向允许我们改变输出的位置和输入的来源。 通常，输出从屏幕上显示而输入则来自于键盘，但是通过I / O重定向，我们可以改变它。\nRedirecting Standard Output 重定向标准输出把ls -l /usr/bin的结果通过&gt;重定向到ls-output.txt这个文件\nls -l &#x2F;usr&#x2F;bin &gt; ls-output.txt\n\n当你想把ls -l /bin/usr的结果通过&gt;重定向到ls-output.txt这个文件时，你会发现并不可行，因为ls这个命令不会把它的错误信息通过标准输出的方式进行输出\n[root@golinux playground]# ls -l &#x2F;bin&#x2F;usr &gt; ls-output.txt\nls: cannot access &#x2F;bin&#x2F;usr: No such file or directory\n\n\n\n\n操作符\n功能\n\n\n\n&gt;\n重写内容\n\n\n&gt;&gt;\n追加内容\n\n\nRedirecting Standard Error 重定向标准错误要重定向标准错误，我们必须引用其文件描述符。 程序可以在几个编号的文件流中的任何一个上产生输出。 虽然我们将前三个文件流称为标准输入，输出和错误，但shell在内部分别将它们作为文件描述符0,1和2引用。 shell提供了使用文件描述符编号重定向文件的表示法。 由于标准错误与文件描述符编号2相同，因此我们可以使用以下表示法重定向标准错误：\n文件描述符（File Descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。\n\n\n\n整数值\n名称\n&lt;unistd.h&gt;符号常量\n&lt;stdio.h&gt;文件流\n\n\n\n0\nStandard input\nSTDIN_FILENO\nstdin\n\n\n1\nStandard output\nSTDOUT_FILENO\nstdout\n\n\n2\nStandard error\nSTDERR_FILENO\nstderr\n\n\n重定向标准错误到文件\nls -l &#x2F;bin&#x2F;usr 2&gt; ls-error.txt\n\n重定向标准输出和标准错误到同一个文件\nls -l &#x2F;bin&#x2F;usr &gt; ls-output.txt 2&gt;&amp;1\n# 或者\nls -l &#x2F;bin&#x2F;usr &amp;&gt; ls-output.txt\n\n处理不需要的输出\nls -l &#x2F;bin&#x2F;usr 2&gt; &#x2F;dev&#x2F;null\n\n\n\n\n\n\n\n\n\n\n关于/dev/null的趣闻\nRedirecting Standard Input 重定向标准输入cat - 合并输出文件显示内容不多的文本文件\ncat ls-output.txt\n\n合并文件，比如我们有 movie.mpeg.001 movie.mpeg.002 ... movie.mpeg.099 这些文件，使用如下命令就可以合并成一个文件\ncat movie.mpeg.0* &gt; movie.mpeg\n\n只输入cat就变成了输入什么输出什么的交互命令行\n[root@golinux playground]# cat\nhello world\nhello world\n\n利用这个特性可以用cat创建内容不多的文本文件\n[root@izbp13gye2rcpn1at3vj69z playground]# cat &gt; little.txt\nthis is a little.txt # 输入文件内容\n[root@izbp13gye2rcpn1at3vj69z playground]# cat little.txt \nthis is a little.txt # 打印文件内容\n\n使用&lt; 重定向操作符，我们将标准输入源从键盘更改为little.txt 文件。\n我们可以看到结果与cat little.txt这种传递单个文件名参数的结果相同\n[root@izbp13gye2rcpn1at3vj69z playground]# cat &lt; little.txt \nthis is the little.txt\n\nPipelines 管道操作符管道运算符| 可以把一个命令的标准输出传递到另一命令的标准输入\n\n\n举个栗子 通过管道运算符 我们可以把 /的目录信息通过less命令打印出来\n[root@golinux playground]# ll &#x2F; | less\n\n管道通常用于对数据执行复杂的操作。 可以将几个命令放到管道中。 通常，以这种方式使用的命令称为过滤器。 过滤器接受输入，以某种方式对其进行更改，然后输出。 我们将尝试的第一个是sort。 想象我们想在/bin和/usr/bin中列出所有可执行程序的组合列表，将它们按排序顺序放置，然后查看结果列表。\nls &#x2F;bin &#x2F;usr&#x2F;bin&#x2F; | sort | less\n\n\n\n\n\n\n\n\n\n\n&gt;与 |的区别\n简单来讲，重定向操作符&gt;将命令与文件连接，而管道操作符|将一个命令的输出与第二个命令的输入连接。\ncommand1 &gt; file1\ncommand1 | command2\n\n\n\n命令\nEN\nZH\n\n\n\nuniq\nReport or Omit Repeated Lines\n忽略重复的行\n\n\nwc\nPrint Line, Word, and Byte Counts\n打印行数，字数和字节数\n\n\ngrep\nPrint Lines Matching a Pattern\n匹配模式\n\n\nhead/tail\nPrint First/Last Part of Files\n打印文件的最前/最后一部分\n\n\ntee\nRead from Stdin and Output to Stdout and Files\n从Stdin读取并输出到Stdout和文件\n\n\n07 - Seeing the World as the Shell Sees it 用脚本解决问题08 - Advanced Keyboard Tricks 高级键盘技巧09 - Permissions 权限10 -  Processes 进程11 - The Environment 环境12 - A Gentle Introduction to VIM 一个柔和的 VIM 介绍13 - Customizing the Prompt 自定义提示","slug":"Learning-The-Shell","date":"2021-01-11T23:48:21.000Z","categories_index":"运维","tags_index":"Linux","author_index":"ZV"},{"id":"923873964bedc6d39520ffd3396ca0ce","title":"使用nvm管理Node.js版本","content":"背景在实验 Vue3 的时候，提示 Error: Cannot find module &#39;vue-loader-v16/package.json&#39;，排查后发现是Node.js npm的问题于是安装了最新的 14.15.4 LTS，但是在解决完 Vue3的问题后，使用 npm打包老项目又挂了，所以决定使用 nvm去管理 Node.js的版本\n安装因为是使用 windows开发，所以使用 nvm-windows，版本选择最新的就可以。\n安装完毕之后，需要去 C:\\Users\\&#123;用户名&#125;\\AppData\\Roaming\\nvm目录下，给 settings.txt添加 node_mirror和 npm_mirror配置\nroot: C:\\Users\\emotionl\\AppData\\Roaming\\nvm\npath: D:\\Program Files\\nodejs\nnode_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node&#x2F;\nnpm_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;npm&#x2F;\n\n使用安装想要使用的 Node.js 版本\nnvm install &lt;version&gt;\n\n查看已安装的 Node.js 版本\nnvm list [available]  \n\n使用已经安装的 Node.js 版本\nnvm use [version]\n\n","slug":"使用nvm管理Node-js版本","date":"2021-01-07T17:12:09.000Z","categories_index":"前端","tags_index":"Node.js","author_index":"ZV"},{"id":"391e5379613c514b7c0c8a55534d752c","title":"试试 Proxy 和 Reflect","content":"Proxy使用 Object.defineProperty()模拟Vue的数据绑定\nclass VData &#123;\n  constructor(&#123; data &#125;) &#123;\n    this.data &#x3D; data\n    this.bindData(data)\n  &#125;\n  bindData(data) &#123;\n    const newData &#x3D; &#123;&#125;\n    for (const key in data) &#123;\n      if (data.hasOwnProperty(key)) &#123;\n        newData[key] &#x3D; data[key]\n        Object.defineProperty(data, key, &#123;\n          get() &#123;\n            return newData[key]\n          &#125;,\n          set(val) &#123;\n            newData[key] &#x3D; val\n          &#125;\n        &#125;)\n      &#125;\n    &#125;\n  &#125;\n&#125;\nconst v &#x3D; new VData(&#123;\n  data: &#123;\n    a: 1,\n    b: 2\n  &#125;\n&#125;)\n\n使用Proxy封装一个可设置类型的数组TypeArray，并且对数组中不存在的值返回默认值\nconst TypeArray &#x3D; (type, defaultValue &#x3D; &#39;N&#x2F;A&#39;, initArray &#x3D; []) &#x3D;&gt; &#123;\n  return new Proxy(initArray, &#123;\n    get(target, prop) &#123;\n      return target[prop] || defaultValue\n    &#125;,\n    set(target, prop, value) &#123;\n      if (typeof value &#x3D;&#x3D;&#x3D; type || prop &#x3D;&#x3D;&#x3D; &#39;length&#39;) &#123;\n        target[prop] &#x3D; value\n        return true\n      &#125; else &#123;\n        return false\n      &#125;\n    &#125;\n  &#125;)\n&#125;\n\nconst numArr &#x3D; TypeArray(&#39;number&#39;)\nnumArr.push(1)   &#x2F;&#x2F; Proxy 代理数组 数组本身的方法属性不会被破坏\nnumArr.push(&quot;2&quot;) &#x2F;&#x2F; Uncaught TypeError: &#39;set&#39; on proxy: trap returned falsish for property &#39;2&#39; at Proxy.push (&lt;anonymous&gt;)\n\n使用 has方法捕获in操作符\nconst checkRange &#x3D; new Proxy(\n  &#123;\n    start: 0,\n    end: 100\n  &#125;,\n  &#123;\n    has(target, prop) &#123;\n      return prop &gt;&#x3D; target.start &amp;&amp; prop &lt;&#x3D; target.end\n    &#125;\n  &#125;\n)\n\nconsole.log(50 in checkRange)\t&#x2F;&#x2F; false\nconsole.log(150 in checkRange)\t&#x2F;&#x2F; true\n\n使用ownKeys拦截 Reflect.ownKeys()也可以拦截 Object.keys() ; for in Loop ; Object.getOwnPropertySymbols() 中的部分的 key \nconst obj &#x3D; &#123;\n  attr: &#39;attr&#39;,\n  _attr: &#39;_attr&#39;,\n  [Symbol(&#39;attr&#39;)]: &#39;Symbol(attr)&#39;,\n  [Symbol(&#39;_attr&#39;)]: &#39;Symbol(_attr)&#39;\n&#125;\n\n&#x2F;&#x2F; 未使用 Proxy 的 ownKeys 拦截\nconsole.log(Object.keys(obj)) &#x2F;&#x2F; [&quot;attr&quot;, &quot;_attr&quot;]\nconsole.log(Object.getOwnPropertySymbols(obj)) &#x2F;&#x2F; [Symbol(attr), Symbol(_attr)]\nconsole.log(Reflect.ownKeys(obj)) &#x2F;&#x2F; [&quot;attr&quot;, &quot;_attr&quot;, Symbol(attr), Symbol(_attr)]\nfor (const key in obj) &#123;\n  console.log(key) &#x2F;&#x2F; attr _attr\n&#125;\n\n&#x2F;&#x2F; 使用 Proxy 的 ownKeys 拦截\nconst p &#x3D; new Proxy(obj, &#123;\n  ownKeys(target) &#123;\n    const normalKeys &#x3D; Object.keys(target)\n    const normalFilterKeys &#x3D; normalKeys.filter((key) &#x3D;&gt; !key.startsWith(&#39;_&#39;)) &#x2F;&#x2F; 拦截以下划线开头的 key\n    const symbolKeys &#x3D; Object.getOwnPropertySymbols(target)\n    const symbolFilterKeys &#x3D; symbolKeys.filter((key) &#x3D;&gt; !key.toString().startsWith(&#39;Symbol(_&#39;)) &#x2F;&#x2F; 拦截以下划线开头的 key\n    return [...normalFilterKeys, ...symbolFilterKeys]\n  &#125;\n&#125;)\n\nconsole.log(Object.keys(p)) &#x2F;&#x2F; [&quot;attr&quot;]\nconsole.log(Object.getOwnPropertySymbols(p)) &#x2F;&#x2F; [Symbol(attr)]\nconsole.log(Reflect.ownKeys(p)) &#x2F;&#x2F; [&quot;attr&quot;, Symbol(attr)]\nfor (const key in p) &#123;\n  console.log(key) &#x2F;&#x2F; attr\n&#125;\n\n来个综合案例\nconst userInfo &#x3D; &#123;\n  name: &#39;Jack&#39;,\n  age: 17,\n  _address: &#39;London UK&#39;\n&#125;\n\nconst p &#x3D; new Proxy(userInfo, &#123;\n  get(target, prop) &#123;\n    if (prop.startsWith(&#39;_&#39;)) &#123;\n      throw new Error(&#96;$&#123;prop&#125; 不可访问&#96;)\n    &#125; else &#123;\n      return target[prop] || &#39;N&#x2F;A&#39;\n    &#125;\n  &#125;,\n  set(target, prop, value) &#123;\n    if (prop.startsWith(&#39;_&#39;)) &#123;\n      throw new Error(&#96;不能设置 $&#123;prop&#125;&#96;)\n    &#125; else &#123;\n      target[prop] &#x3D; value\n      return true\n    &#125;\n  &#125;,\n  deleteProperty(target, prop) &#123;\n    if (prop.startsWith(&#39;_&#39;)) &#123;\n      throw new Error(&#96;不能删除$&#123;prop&#125;&#96;)\n    &#125; else &#123;\n      delete target[prop]\n      return true\n    &#125;\n  &#125;,\n  ownKeys(target) &#123;\n    return Object.keys(target).filter((key) &#x3D;&gt; !key.startsWith(&#39;_&#39;))\n  &#125;\n&#125;)\n\n使用 apply拦截函数的调用（包装函数）\nconst sum &#x3D; (a, b) &#x3D;&gt; &#123;\n  return a + b\n&#125;\n\nconst sumText &#x3D; new Proxy(sum, &#123;\n  apply(target, thisArg, argArray) &#123;\n    return &#96;total number is $&#123;target(...argArray)&#125;&#96;\n  &#125;\n&#125;)\n\nsumText(10, 20)\n\n","slug":"试试 Proxy 和 Reflect","date":"2020-08-26T00:00:00.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"ZV"},{"id":"c1e7e740a56d87809715d43780d153ea","title":"复习一下Generator的使用","content":"先来个例题 看一下结果\nfunction* addGen(x) &#123;\n  let y &#x3D; (yield x + 5) * 2\n  let z &#x3D; yield y &#x2F; 4\n  return x + y + z\n&#125;\n\nlet g &#x3D; addGen(1)\nconsole.log(g.next()) &#x2F;&#x2F; 1&gt; &#123;value: 6, done: false&#125;\nconsole.log(g.next()) &#x2F;&#x2F; 2&gt; &#123;value: NaN, done: false&#125;\nconsole.log(g.next()) &#x2F;&#x2F; 3&gt; &#123;value: NaN, done: true&#125;\n&#x2F;* \n  1&gt; g.next() 返回的 value 是 x + 5 &#x3D;&gt; 6\n  2&gt; g.next() 返回的 value 是 y &#x2F; 3，由于本次 g.next() 并未传值，所以 y &#x3D; undefined * 2 &#x3D;&gt; NaN，所以本次的 value 是 NaN &#x2F; 3 &#x3D;&gt; NaN\n  3&gt; g.next() 返回的 value 是 x + y + z &#x3D;&gt; 1 + NaN + NaN &#x3D;&gt; NaN\n*&#x2F;\n\n如何让以上代码执行的更符合一般的逻辑y = (1 + 5) * 2 ; z = y / 4，最后返回 16\nfunction* addGen(x) &#123;\n  let y &#x3D; (yield x + 5) * 2\n  let z &#x3D; yield y &#x2F; 4\n  return x + y + z\n&#125;\n\nlet g &#x3D; addGen(1)\nlet v1 &#x3D; g.next().value\nlet v2 &#x3D; g.next(v1).value\nlet v3 &#x3D; g.next(v2).value\nconsole.log(v3)\n\n再来个实例，以 “敲七” 这个游戏为例，从零开始获取每一个符合 “敲七” 的数字\nfunction* count7Gen(count &#x3D; 1) &#123;\n  while (true) &#123;\n    if (count % 7 &#x3D;&#x3D;&#x3D; 0 || count % 10 &#x3D;&#x3D;&#x3D; 7) &#123;\n      yield count\n    &#125;\n    count++\n  &#125;\n&#125;\n\nconst c7g &#x3D; count7Gen()\n\nconsole.log(c7g.next()) &#x2F;&#x2F; &#123;value: 7, done: false&#125;\nconsole.log(c7g.next()) &#x2F;&#x2F; &#123;value: 14, done: false&#125;\nconsole.log(c7g.next()) &#x2F;&#x2F; &#123;value: 17, done: false&#125;\nconsole.log(c7g.next()) &#x2F;&#x2F; &#123;value: 21, done: false&#125;\nconsole.log(c7g.next()) &#x2F;&#x2F; &#123;value: 27, done: false&#125;\n\n\n\n\n\n\n\n\n\n\ncount7Gen这个函数本身是一个死循环，但是 Generator这种模式使其能在特定的节点停止或继续\n模拟一个简单的 Generator\nconst makeGenerator &#x3D; (list) &#x3D;&gt; &#123;\n  let index &#x3D; 0\n  return &#123;\n    next: () &#x3D;&gt; &#123;\n      const value &#x3D; list[index++]\n      const done &#x3D; index &gt;&#x3D; list.length\n      return &#123; value, done &#125;\n    &#125;\n  &#125;\n&#125;\n\nconst g &#x3D; makeGenerator([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])\nconsole.log(g.next())\nconsole.log(g.next())\nconsole.log(g.next())\nconsole.log(g.next())\n","slug":"复习一下Generator的使用","date":"2020-08-25T00:00:00.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"ZV"},{"id":"13fdecdad2e10251171eb5f21046894a","title":"Nestjs 开发流","content":"\n\nEntity定义数据\nimport &#123; BaseEntity, Entity, PrimaryGeneratedColumn, Column &#125; from &#39;typeorm&#39;\nimport &#123; TaskStatus &#125; from &#39;.&#x2F;task-status.enum&#39;\n\n@Entity()\nexport class Task extends BaseEntity &#123;\n  @PrimaryGeneratedColumn() &#x2F;&#x2F; 定义主键\n  id: number\n\n  @Column()\n  title: string\n\n  @Column()\n  description: string\n\n  @Column()\n  status: TaskStatus\n&#125;\n\nRepository操作数据\nimport &#123; Task &#125; from &#39;.&#x2F;task.entity&#39;\nimport &#123; EntityRepository, Repository &#125; from &#39;typeorm&#39;\nimport &#123; CreateTaskDto &#125; from &#39;.&#x2F;dto&#x2F;create-task.dto&#39;\nimport &#123; TaskStatus &#125; from &#39;.&#x2F;task-status.enum&#39;\nimport &#123; GetTasksFilterDto &#125; from &#39;.&#x2F;dto&#x2F;get-tasks-filter-dto&#39;\n\n@EntityRepository(Task)\nexport class TaskRepository extends Repository&lt;Task&gt; &#123;\n  &#x2F;&#x2F; 继承 Repository 享用 findOne delete 等操作\n  async getTasks(filterDto: GetTasksFilterDto): Promise&lt;Task[]&gt; &#123;\n    const &#123; status, search &#125; &#x3D; filterDto\n    const query &#x3D; this.createQueryBuilder(&#39;task&#39;) &#x2F;&#x2F; 使用 QueryBuilder 生成 SQL\n    if (status) &#123;\n      query.andWhere(&#39;task.status &#x3D; :status&#39;, &#123; status &#125;) &#x2F;&#x2F; 添加条件\n    &#125;\n    if (search) &#123;\n      query.andWhere(&#39;task.title LIKE :search OR task.description LIKE :search&#39;, &#123; search: &#96;%$&#123;search&#125;%&#96; &#125;)\n    &#125;\n    const tasks &#x3D; await query.getMany() &#x2F;&#x2F; 执行 SQL 获取数据\n    return tasks\n  &#125;\n\n  async createTask(createTaskDto: CreateTaskDto): Promise&lt;Task&gt; &#123;\n    const &#123; title, description &#125; &#x3D; createTaskDto\n    const task &#x3D; new Task()\n    task.title &#x3D; title\n    task.description &#x3D; description\n    task.status &#x3D; TaskStatus.OPEN\n    await task.save()\n    return task\n  &#125;\n&#125;\n\nService提供服务\nimport &#123; Injectable, NotFoundException &#125; from &#39;@nestjs&#x2F;common&#39;\nimport &#123; CreateTaskDto &#125; from &#39;.&#x2F;dto&#x2F;create-task.dto&#39;\nimport &#123; GetTasksFilterDto &#125; from &#39;.&#x2F;dto&#x2F;get-tasks-filter-dto&#39;\nimport &#123; UpdateTaskStatusDto &#125; from &#39;.&#x2F;dto&#x2F;update-task-status.dto&#39;\nimport &#123; TaskRepository &#125; from &#39;.&#x2F;task.repository&#39;\nimport &#123; InjectRepository &#125; from &#39;@nestjs&#x2F;typeorm&#39;\nimport &#123; Task &#125; from &#39;.&#x2F;task.entity&#39;\nimport &#123; TaskStatus &#125; from &#39;.&#x2F;task-status.enum&#39;\n\n@Injectable()\nexport class TasksService &#123;\n  constructor(\n    @InjectRepository(TaskRepository)\n    private taskRepository: TaskRepository\n  ) &#123;&#125;\n\n  async getTasks(filterDto: GetTasksFilterDto): Promise&lt;Task[]&gt; &#123;\n    return this.taskRepository.getTasks(filterDto) &#x2F;&#x2F; 调用 TaskRepository 中封装好的数据操作\n  &#125;\n\n  async getTaskById(id: number): Promise&lt;Task&gt; &#123;\n    &#x2F;&#x2F; 当数据操作比较简单时 可以直接调用 Repository 的方法\n    const foundTask &#x3D; await this.taskRepository.findOne(id)\n    if (!foundTask) throw new NotFoundException(&#96;Task with ID $&#123;id&#125; not found&#96;)\n    return foundTask\n  &#125;\n\n  async createTask(createTaskDto: CreateTaskDto): Promise&lt;Task&gt; &#123;\n    return this.taskRepository.createTask(createTaskDto)\n  &#125;\n\n  async deleteTask(id: number): Promise&lt;any&gt; &#123;\n    const result &#x3D; await this.taskRepository.delete(id)\n    if (result.affected &#x3D;&#x3D;&#x3D; 0) throw new NotFoundException(&#96;Task with ID $&#123;id&#125; not found&#96;)\n  &#125;\n\n  async updateTaskStatus(updateTaskStatusDto: UpdateTaskStatusDto): Promise&lt;Task&gt; &#123;\n    const &#123; id, status &#125; &#x3D; updateTaskStatusDto\n    const foundTask &#x3D; await this.getTaskById(id)\n    foundTask.status &#x3D; TaskStatus[status]\n    await foundTask.save()\n    return foundTask\n  &#125;\n&#125;\n\nController处理请求\nimport &#123; Controller, Get, Post, Body, Param, Query, UsePipes, ValidationPipe, ParseIntPipe &#125; from &#39;@nestjs&#x2F;common&#39;\nimport &#123; TasksService &#125; from &#39;.&#x2F;tasks.service&#39;\nimport &#123; CreateTaskDto &#125; from &#39;.&#x2F;dto&#x2F;create-task.dto&#39;\nimport &#123; GetTasksFilterDto &#125; from &#39;.&#x2F;dto&#x2F;get-tasks-filter-dto&#39;\nimport &#123; UpdateTaskStatusDto &#125; from &#39;.&#x2F;dto&#x2F;update-task-status.dto&#39;\nimport &#123; Task &#125; from &#39;.&#x2F;task.entity&#39;\n\n@Controller(&#39;tasks&#39;)\nexport class TasksController &#123;\n  constructor(private taskService: TasksService) &#123;&#125;\n\n  @Get()\n  @UsePipes(ValidationPipe) &#x2F;&#x2F; 使用 ValidationPipe 和 DTO 进行字段的校验\n  getTasks(@Query() filterDto: GetTasksFilterDto) &#123;\n    return this.taskService.getTasks(filterDto)\n  &#125;\n\n  @Get(&#39;&#x2F;:id&#39;)\n  getTaskById(@Param(&#39;id&#39;, ParseIntPipe) id: number): Promise&lt;Task&gt; &#123;\n    &#x2F;&#x2F; ParseIntPipe string&#x3D;&gt;number (如果转换失败将抛出异常)\n    return this.taskService.getTaskById(id)\n  &#125;\n\n  @Post(&#39;&#x2F;create&#39;)\n  @UsePipes(ValidationPipe)\n  createTask(@Body() createTaskDto: CreateTaskDto): Promise&lt;Task&gt; &#123;\n    return this.taskService.createTask(createTaskDto)\n  &#125;\n\n  @Post(&#39;&#x2F;delete&#39;)\n  deleteTask(@Body(&#39;id&#39;, ParseIntPipe) id: number): Promise&lt;void&gt; &#123;\n    return this.taskService.deleteTask(id)\n  &#125;\n\n  @Post(&#39;&#x2F;status&#x2F;update&#39;)\n  @UsePipes(ValidationPipe)\n  async updateTaskStatus(@Body() updateTaskStatusDto: UpdateTaskStatusDto): Promise&lt;Task&gt; &#123;\n    return this.taskService.updateTaskStatus(updateTaskStatusDto)\n  &#125;\n&#125;\n","slug":"Nestjs 开发流","date":"2020-08-13T00:00:00.000Z","categories_index":"拓展","tags_index":"Node.js","author_index":"ZV"},{"id":"ddc597ec7f043c7134b0654946012fa0","title":"百度地图与React","content":"WEB 端文档\nJavaScript API\n微信小程序 JavaScript API\n地铁图 JavaScript API\n位置数据可视化 MapV GL\n\n与 React 结合以 JavaScript API GL v1.0 版本的 SDK为例\n\n首先在public\\index.html添加引入 BMapGL\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot; dir&#x3D;&quot;ltr&quot;&gt;\n\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;shortcut icon&quot; href&#x3D;&quot;%PUBLIC_URL%&#x2F;favicon.ico&quot; &#x2F;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1&quot; &#x2F;&gt;\n  &lt;meta name&#x3D;&quot;theme-color&quot; content&#x3D;&quot;#000000&quot; &#x2F;&gt;\n  &lt;link rel&#x3D;&quot;manifest&quot; href&#x3D;&quot;%PUBLIC_URL%&#x2F;manifest.json&quot; &#x2F;&gt;\n  &lt;!-- 引入 BMapGL --&gt;\n  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;api.map.baidu.com&#x2F;api?type&#x3D;webgl&amp;v&#x3D;1.0&amp;ak&#x3D;4gaWxQf2AUtC51IhrHLVVUW5f10K1GTN&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;title&gt;Title&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n  &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n\n修改config-overrides.js添加externals配置\nconst &#123;\n  override,\n  addWebpackPlugin,\n  addPostcssPlugins,\n  addWebpackExternals\n&#125; &#x3D; require(&#39;customize-cra&#39;)\nconst WebpackBuildNotifierPlugin &#x3D; require(&#39;webpack-build-notifier&#39;)\nconst WebpackBar &#x3D; require(&#39;webpackbar&#39;)\n\nconst path &#x3D; require(&#39;path&#39;)\n\nmodule.exports &#x3D; &#123;\n  webpack: override(\n    addWebpackPlugin(\n      new WebpackBar(),\n      new WebpackBuildNotifierPlugin(&#123;\n        title: &#39;MISSION SUCCESS!&#39;,\n        logo: path.resolve(&#39;.&#x2F;src&#x2F;logo.svg&#39;),\n        suppressSuccess: true\n      &#125;)\n    ),\n    addPostcssPlugins([require(&#39;postcss-rtl&#39;)()]),\n    &#x2F;&#x2F; 添加 externals 配置\n    addWebpackExternals(&#123;\n      BMapGL: &#39;BMapGL&#39;\n    &#125;)\n  )\n&#125;\n\n最后导入并使用BMapGL\nimport React, &#123; useRef, useEffect &#125; from &#39;react&#39;\nimport BMapGL from &#39;BMapGL&#39;\nimport &#123; Card &#125; from &#39;reactstrap&#39;\n\nconst BMapDemo &#x3D; () &#x3D;&gt; &#123;\n  const bMapContainerRef &#x3D; useRef(null)\n\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 创建 BMapGL 实例\n    const bMap &#x3D; new BMapGL.Map(bMapContainerRef.current)\n    &#x2F;&#x2F; 初始化中心点坐标\n    const point &#x3D; new BMapGL.Point(116.404, 39.915)\n    &#x2F;&#x2F; 初始化地图，设置中心点坐标和地图级别\n    bMap.centerAndZoom(point, 12)\n    bMap.enableScrollWheelZoom(true)\n  &#125;, [])\n\n  return (\n    &lt;Card\n      style&#x3D;&#123;&#123;\n        width: &#39;100%&#39;,\n        height: &#39;300px&#39;\n      &#125;&#125;&gt;\n      &lt;div\n        ref&#x3D;&#123;bMapContainerRef&#125;\n        style&#x3D;&#123;&#123;\n          width: &#39;100%&#39;,\n          height: &#39;100%&#39;\n        &#125;&#125;\n      &#x2F;&gt;\n    &lt;&#x2F;Card&gt;\n  )\n&#125;\n\n\n\n","slug":"百度地图与React","date":"2020-07-21T00:00:00.000Z","categories_index":"前端","tags_index":"JavaScript,React","author_index":"ZV"},{"id":"b713a5ec769cb744eeaf48bdf6c140c9","title":"分析一道「微信」面试题","content":"题目：实现一个 LazyMan，按照以下方式调用时，得到相关输出：\nLazyMan(&#39;Hank&#39;)\n&#x2F;&#x2F; Hi! This is Hank!\nLazyMan(&#39;Hank&#39;).sleep(10).eat(&#39;dinner&#39;)\n&#x2F;&#x2F; Hi! This is Hank!\n&#x2F;&#x2F; 等待 10 秒..\n&#x2F;&#x2F; Wake up after 10\n&#x2F;&#x2F; Eat dinner~\nLazyMan(&#39;Hank&#39;).eat(&#39;dinner&#39;).eat(&#39;supper&#39;)\n&#x2F;&#x2F; Hi This is Hank!\n&#x2F;&#x2F; Eat dinner~\n&#x2F;&#x2F; Eat supper~\nLazyMan(&#39;Hank&#39;).sleepFirst(5).eat(&#39;supper&#39;)\n&#x2F;&#x2F; 等待 5 秒\n&#x2F;&#x2F; Wake up after 5\n&#x2F;&#x2F; Hi This is Hank!\n&#x2F;&#x2F; Eat supper\n\n代码实现：\nclass LazyManCreator &#123;\n  constructor(name) &#123;\n    this.taskList &#x3D; []\n    const task &#x3D; () &#x3D;&gt; &#123;\n      console.log(&#96;Hi! This is $&#123;name&#125;!&#96;)\n      this.next()\n    &#125;\n    this.taskList.push(task)\n    setTimeout(() &#x3D;&gt; &#123;\n      this.next()\n    &#125;, 0)\n  &#125;\n  next() &#123;\n    const task &#x3D; this.taskList.shift()\n    task &amp;&amp; task()\n  &#125;\n  sleep(timeout) &#123;\n    const task &#x3D; () &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        console.log(&#96;Wake up after $&#123;timeout&#125;&#96;)\n        this.next()\n      &#125;, timeout * 1000)\n    &#125;\n    this.taskList.push(task)\n    return this\n  &#125;\n  sleepFirst(timeout) &#123;\n    const task &#x3D; () &#x3D;&gt; &#123;\n      setTimeout(() &#x3D;&gt; &#123;\n        console.log(&#96;Wake up after $&#123;timeout&#125;&#96;)\n        this.next()\n      &#125;, timeout * 1000)\n    &#125;\n    this.taskList.unshift(task)\n    return this\n  &#125;\n  eat(meal) &#123;\n    const task &#x3D; () &#x3D;&gt; &#123;\n      console.log(&#96;Eat $&#123;meal&#125;&#96;)\n      this.next()\n    &#125;\n    this.taskList.push(task)\n    return this\n  &#125;\n&#125;\n\nconst LazyMan &#x3D; name &#x3D;&gt; &#123;\n  return new LazyManCreator(name)\n&#125;\n\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nLazyMan(&#39;Hank&#39;).sleepFirst(5).eat(&#39;supper&#39;)\n\n追加一道类似的题目：实现下面这道题中的machine函数\nfunction machine() &#123;\n    \n&#125;\nmachine(&#39;ygy&#39;).execute() \n&#x2F;&#x2F; start ygy\nmachine(&#39;ygy&#39;).do(&#39;eat&#39;).execute(); \n&#x2F;&#x2F; start ygy\n&#x2F;&#x2F; ygy eat\nmachine(&#39;ygy&#39;).wait(5).do(&#39;eat&#39;).execute();\n&#x2F;&#x2F; start ygy\n&#x2F;&#x2F; wait 5s（这里等待了5s）\n&#x2F;&#x2F; ygy eat\nmachine(&#39;ygy&#39;).waitFirst(5).do(&#39;eat&#39;).execute();\n&#x2F;&#x2F; wait 5s\n&#x2F;&#x2F; start ygy\n&#x2F;&#x2F; ygy eat\n\n代码实现：\nfunction machine(name) &#123;\n  class Machine &#123;\n    constructor(name) &#123;\n      this.name &#x3D; name\n      this.taskList &#x3D; []\n      const task &#x3D; () &#x3D;&gt; &#123;\n        console.log(&#96;start $&#123;this.name&#125;&#96;)\n        this.next()\n      &#125;\n      this.taskList.push(task)\n    &#125;\n    next() &#123;\n      const task &#x3D; this.taskList.shift()\n      task &amp;&amp; task()\n    &#125;\n    execute() &#123;\n      this.next()\n    &#125;\n    do(something) &#123;\n      const task &#x3D; () &#x3D;&gt; &#123;\n        console.log(&#96;$&#123;this.name&#125; $&#123;something&#125;&#96;)\n        this.next()\n      &#125;\n      this.taskList.push(task)\n      return this\n    &#125;\n    wait(timeout) &#123;\n      const task &#x3D; () &#x3D;&gt; &#123;\n        console.log(&#96;wait $&#123;timeout&#125;s&#96;)\n        setTimeout(() &#x3D;&gt; &#123;\n          this.next()\n        &#125;, 1000 * timeout)\n      &#125;\n      this.taskList.push(task)\n      return this\n    &#125;\n    waitFirst(timeout) &#123;\n      const task &#x3D; () &#x3D;&gt; &#123;\n        console.log(&#96;wait $&#123;timeout&#125;s&#96;)\n        setTimeout(() &#x3D;&gt; &#123;\n          this.next()\n        &#125;, 1000 * timeout)\n      &#125;\n      this.taskList.unshift(task)\n      return this\n    &#125;\n  &#125;\n  return new Machine(name)\n&#125;\n\n","slug":"分析一道「微信」面试题","date":"2020-06-05T00:00:00.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"ZV"},{"id":"3db723625fe9f0ccdae76ec1059696b7","title":"实现一个集合","content":"class CustomSet &#123;\n  constructor() &#123;\n    this.items &#x3D; &#123;&#125;\n  &#125;\n  getKeyForValue(value) &#123;\n    return Symbol.for(value)\n  &#125;\n  add(value) &#123;\n    if (!this.has(value)) this.items[this.getKeyForValue(value)] &#x3D; value\n    return this\n  &#125;\n  clear() &#123;\n    this.items &#x3D; &#123;&#125;\n  &#125;\n  delete(value) &#123;\n    if (this.has(value)) delete this.items[this.getKeyForValue(value)]\n  &#125;\n  has(value) &#123;\n    const key &#x3D; this.getKeyForValue(value)\n    const keyList &#x3D; Object.getOwnPropertySymbols(this.items)\n    return keyList.some(item &#x3D;&gt; item &#x3D;&#x3D;&#x3D; key)\n  &#125;\n  size() &#123;\n    return Object.getOwnPropertySymbols(this.items).length\n  &#125;\n  values() &#123;\n    return Object.getOwnPropertySymbols(this.items).map(key &#x3D;&gt; this.items[key])\n  &#125;\n  &#x2F;&#x2F; 并集\n  union(otherSet) &#123;\n    const unionSet &#x3D; new CustomSet()\n    this.values().forEach(values &#x3D;&gt; unionSet.add(values))\n    otherSet.values().forEach(values &#x3D;&gt; unionSet.add(values))\n    return unionSet\n  &#125;\n  &#x2F;&#x2F; 交集\n  intersection(otherSet) &#123;\n    const intersectionSet &#x3D; new CustomSet()\n    this.values().forEach(value &#x3D;&gt; &#123;\n      if (otherSet.has(value)) &#123;\n        intersectionSet.add(value)\n      &#125;\n    &#125;)\n    return intersectionSet\n  &#125;\n  &#x2F;&#x2F; 差集\n  difference(otherSet) &#123;\n    const differenceSet &#x3D; new CustomSet()\n    this.values().forEach(value &#x3D;&gt; &#123;\n      if (!otherSet.has(value)) &#123;\n        differenceSet.add(value)\n      &#125;\n    &#125;)\n    return differenceSet\n  &#125;\n  &#x2F;&#x2F; 子集\n  isSubsetOf(otherSet) &#123;\n    if (this.size() &gt; otherSet.size()) return false\n    return this.values().every(value &#x3D;&gt; &#123;\n      return otherSet.has(value)\n    &#125;)\n  &#125;\n&#125;\n\nconst s1 &#x3D; new CustomSet()\ns1.add(1).add(2).add(3).add(4)\nconst s2 &#x3D; new CustomSet()\ns2.add(&#39;Jack&#39;).add(&#39;Tim&#39;).add(&#39;David&#39;)\nconst s3 &#x3D; s1.union(s2)\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nconsole.log(s3.values())\nconst s4 &#x3D; new CustomSet()\ns4.add(3).add(4).add(5).add(6)\nconst s5 &#x3D; s1.intersection(s4)\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nconsole.log(s5.values())\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nconst s6 &#x3D; s1.difference(s4)\nconsole.log(s6.values())\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nconst s7 &#x3D; new CustomSet()\ns7.add(1).add(2).add(3).add(4).add(5).add(6)\nconsole.log(s1.isSubsetOf(s7))\n\n","slug":"实现一个集合","date":"2020-06-04T00:00:00.000Z","categories_index":"基础","tags_index":"算法","author_index":"ZV"},{"id":"f24dd06beb414de62fa30f4650dc3e1e","title":"给我来棵二叉树","content":"&#x2F;&#x2F; 声明节点\nclass Node &#123;\n  constructor(key) &#123;\n    this.key &#x3D; key\n    this.left &#x3D; null\n    this.right &#x3D; null\n  &#125;\n&#125;\n\nclass BST &#123;\n  constructor() &#123;\n    this.root &#x3D; null\n  &#125;\n  &#x2F;&#x2F; 新增节点\n  insert(key) &#123;\n    if (this.root &#x3D;&#x3D;&#x3D; null) &#123;\n      this.root &#x3D; new Node(key)\n    &#125; else &#123;\n      this._insertNode(this.root, key)\n    &#125;\n  &#125;\n  _insertNode(node, key) &#123;\n    if (node &#x3D;&#x3D;&#x3D; null) return\n    if (key &lt; node.key) &#123;\n      if (node.left &#x3D;&#x3D;&#x3D; null) &#123;\n        node.left &#x3D; new Node(key)\n      &#125; else &#123;\n        this._insertNode(node.left, key)\n      &#125;\n    &#125; else &#123;\n      if (node.right &#x3D;&#x3D;&#x3D; null) &#123;\n        node.right &#x3D; new Node(key)\n      &#125; else &#123;\n        this._insertNode(node.right, key)\n      &#125;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 中序遍历\n  inOrder(callback) &#123;\n    this._inOrderNode(this.root, callback)\n  &#125;\n  _inOrderNode(node, callback) &#123;\n    if (node !&#x3D;&#x3D; null) &#123;\n      this._inOrderNode(node.left, callback)\n      callback(node.key)\n      this._inOrderNode(node.right, callback)\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 先序遍历\n  preOrder(callback) &#123;\n    this._preOrderNode(this.root, callback)\n  &#125;\n  _preOrderNode(node, callback) &#123;\n    if (node !&#x3D;&#x3D; null) &#123;\n      callback(node.key)\n      this._preOrderNode(node.left, callback)\n      this._preOrderNode(node.right, callback)\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 后续遍历\n  postOrder(callback) &#123;\n    this._postOrderNode(this.root, callback)\n  &#125;\n  _postOrderNode(node, callback) &#123;\n    if (node !&#x3D;&#x3D; null) &#123;\n      this._postOrderNode(node.left, callback)\n      this._postOrderNode(node.right, callback)\n      callback(node.key)\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 最小值\n  min() &#123;\n    return this._minNode(this.root)\n  &#125;\n  _minNode(node) &#123;\n    let currentNode &#x3D; node\n    while (currentNode !&#x3D;&#x3D; null &amp;&amp; currentNode.left !&#x3D;&#x3D; null) &#123;\n      currentNode &#x3D; currentNode.left\n    &#125;\n    return currentNode\n  &#125;\n  &#x2F;&#x2F; 最大值\n  max() &#123;\n    return this._maxNode(this.root)\n  &#125;\n  _maxNode(node) &#123;\n    let currentNode &#x3D; node\n    while (currentNode !&#x3D;&#x3D; null &amp;&amp; currentNode.right !&#x3D;&#x3D; null) &#123;\n      currentNode &#x3D; currentNode.right\n    &#125;\n    return currentNode\n  &#125;\n  &#x2F;&#x2F; 搜索节点\n  search(key) &#123;\n    return this._searchNode(this.root, key)\n  &#125;\n  _searchNode(node, key) &#123;\n    if (node &#x3D;&#x3D;&#x3D; null) &#123;\n      return false\n    &#125;\n    if (key &lt; node.key) &#123;\n      return this._searchNode(node.left, key)\n    &#125; else if (key &gt; node.key) &#123;\n      return this._searchNode(node.right, key)\n    &#125; else &#123;\n      return true\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 移除节点\n  remove(key) &#123;\n    this.root &#x3D; this._removeNode(this.root, key)\n  &#125;\n  _removeNode(node, key) &#123;\n    &#x2F;&#x2F; 节点为空 返回null\n    if (node &#x3D;&#x3D;&#x3D; null) return null\n    &#x2F;&#x2F; key 小于或大于 node.key 继续调用 _removeNode\n    if (key &lt; node.key) &#123;\n      node.left &#x3D; this._removeNode(node.left, key)\n      return node\n    &#125; else if (key &gt; node.key) &#123;\n      node.right &#x3D; this._removeNode(node.right, key)\n      return node\n    &#125; else &#123;\n      &#x2F;&#x2F; key 等于 node.key\n      &#x2F;&#x2F; 第一种情况 搜索到的 node 没有左子树和右子树\n      if (node.left &#x3D;&#x3D;&#x3D; null &amp;&amp; node.right &#x3D;&#x3D;&#x3D; null) &#123;\n        return null\n      &#125;\n      &#x2F;&#x2F; 第二种情况 搜索到的 node 只有一个左子树或右子树\n      if (node.left &#x3D;&#x3D;&#x3D; null) &#123;\n        node &#x3D; node.right\n        return node\n      &#125; else if (node.right &#x3D;&#x3D;&#x3D; null) &#123;\n        node &#x3D; node.left\n        return node\n      &#125;\n      &#x2F;&#x2F; 第三种情况 搜索到的 node 不仅有左子树还有右子树\n      &#x2F;&#x2F; (1) 当找到了要移除的节点后，需要找到它右边子树中最小的节点。\n      &#x2F;&#x2F; (2) 然后，用它右侧子树中最小节点的键去更新这个节点的值。通过这一步，我们改变了这个节点的键，也就是说它被移除了。\n      &#x2F;&#x2F; (3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的最小节点移除，毕竟它已经被移至要移除的节点的位置了。\n      &#x2F;&#x2F; (4) 最后，向它的父节点返回更新后节点的引用。\n      const aux &#x3D; this._minNode(node.right) &#x2F;&#x2F; 找到搜索到的 node 的右子树中的最小节点\n      node.key &#x3D; aux.key &#x2F;&#x2F; 把 aux 的 key 赋值给搜索到的 node\n      node.right &#x3D; this._removeNode(node.right, aux.key) &#x2F;&#x2F; 递归调用 removeNode 用于删除 aux 这个节点\n      return node\n    &#125;\n  &#125;\n&#125;\n\nconst bst &#x3D; new BST()\nconst keyList &#x3D; [5, 4, 3, 7, 6, 8, 2]\nkeyList.forEach(key &#x3D;&gt; bst.insert(key))\nconsole.log(bst)\nconst print &#x3D; val &#x3D;&gt; console.log(val)\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nbst.inOrder(print)\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nbst.preOrder(print)\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nbst.postOrder(print)\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nconsole.log(bst.min())\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nconsole.log(bst.max())\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nconsole.log(&#96;key 2 $&#123;bst.search(2) ? &#39;is exist&#39; : &#39;not exist&#39;&#125;&#96;)\nconsole.log(&#96;key 3 $&#123;bst.search(3) ? &#39;is exist&#39; : &#39;not exist&#39;&#125;&#96;)\nconsole.log(&#96;key 10 $&#123;bst.search(10) ? &#39;is exist&#39; : &#39;not exist&#39;&#125;&#96;)\nconsole.log(&#96;key 6 $&#123;bst.search(100) ? &#39;is exist&#39; : &#39;not exist&#39;&#125;&#96;)\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nbst.remove(8)\nbst.remove(7)\nbst.remove(2)\nbst.inOrder(print)\n\n","slug":"给我来棵二叉树","date":"2020-05-29T00:00:00.000Z","categories_index":"基础","tags_index":"算法","author_index":"ZV"},{"id":"ee82dc5d42257715d56dbfc6d3d2929b","title":"面向对象和原型","content":"实现 new 操作首先，我们先来看看new操作起了什么作用\n&#x2F;&#x2F; 构造函数 People (无显式返回值)\nfunction People(name, age) &#123;\n  this.name &#x3D; name\n  this.age &#x3D; age\n&#125;\n\nPeople.prototype.printInfo &#x3D; function () &#123;\n  return &#96;My name is $&#123;this.name&#125; and $&#123;this.age&#125;&#96;\n&#125;\n\n&#x2F;&#x2F; 构造函数 Student (有显式返回值，且返回值为对象类型)\nfunction Student(name) &#123;\n  this.name &#x3D; name\n  return &#123; ps: &#39;balabala&#39; &#125;\n&#125;\n\nconst p1 &#x3D; new People(&#39;Jack&#39;, 17)\nconst s1 &#x3D; new Student(&#39;David&#39;)\nconsole.log(p1.name)        &#x2F;&#x2F; Jack\nconsole.log(p1.age)         &#x2F;&#x2F; 17\nconsole.log(p1.printInfo()) &#x2F;&#x2F; My name is Jack and 17\nconsole.log(s1)             &#x2F;&#x2F; &#123;ps: &quot;balabala&quot;&#125;\n\n可以看出 new关键字大体上有一下几个作用\n\n构造函数无显式返回值时（例如Person），通过new操作得到的p1 可以访问到构造函数Person里的属性和Person.prototype里的属性\n构造函数有显式返回值并且返回值为对象类型时（例如Student），通过new操作得到的s1是构造函数的显示返回值&#123;ps: &quot;balabala&quot;&#125;\n\n基于以上的内容，我们来实现一个new操作\n\n首先创建一个空对象，这个对象将会作为执行 new 构造函数() 之后，返回的对象实例\n将上面创建的空对象的原型（__proto__），指向构造函数的 prototype 属性\n将这个空对象赋值给构造函数内部的 this，并执行构造函数逻辑\n根据构造函数执行逻辑，返回第一步创建的对象或者构造函数的显式返回值\n\nconst neo &#x3D; (Con, ...args) &#x3D;&gt; &#123;\n  const obj &#x3D; Object.create(Con.prototype)\n  const result &#x3D; Con.apply(obj, args)\n  return typeof result &#x3D;&#x3D;&#x3D; &#39;object&#39; ? result : obj\n&#125;\n\nconst p2 &#x3D; neo(People, &#39;Jason&#39;, 18)\nconst s2 &#x3D; neo(Student, &#39;Doug&#39;)\nconsole.log(p2)\nconsole.log(s2)\n\n\n\n\n\n\n\n\n\n\n\nJavaScript深入之new的模拟实现\n深入浅出JS对象原型\n","slug":"面向对象和原型","date":"2020-05-29T00:00:00.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"ZV"},{"id":"77f168ffc056e7b3c8afc931856a7b37","title":"正则案例4","content":"需求根据需求匹配数据并提取所需数据\n处理前\nconst textList &#x3D; [\n    &#39;@[]&#39;, &#x2F;&#x2F; 不匹配\n    &#39;@[123]&#39;, &#x2F;&#x2F; 不匹配\n    &#39;@asd[133]&#39;, &#x2F;&#x2F; 匹配\n    &#39;@阿里巴巴(杭州)(西湖)[546789][12113][12113][12113][12113][12113][12113]&#39;, &#x2F;&#x2F; 匹配\n    &#39;@阿里巴巴(杭州)(西湖)[12113]&#39;, &#x2F;&#x2F; 匹配\n    &#39;@阿里巴巴[444]&#39; &#x2F;&#x2F; 匹配\n]\n\n处理后\n[\n    &#123; name: &#39;asd&#39;, id: &#39;133&#39; &#125;,\n    &#123; name: &#39;阿里巴巴(杭州)(西湖)&#39;, id: &#39;546789&#39; &#125;,\n    &#123; name: &#39;阿里巴巴(杭州)(西湖)&#39;, id: &#39;12113&#39; &#125;,\n    &#123; name: &#39;阿里巴巴&#39;, id: &#39;444&#39; &#125;\n]\n\n解决方法一&#x2F;&#x2F; 确定处理函数\nconst getFormatTextList &#x3D; (textList) &#x3D;&gt; &#123;\n  const regex &#x3D; &#x2F;\\@([^\\[]+)(?&lt;&#x3D;\\@.+)\\[(\\d+)\\]&#x2F;\n  return textList\n    .filter((item) &#x3D;&gt; regex.test(item))\n    .map((item) &#x3D;&gt; &#123;\n      const [_, name, id] &#x3D; item.match(regex)\n      return &#123;\n        name,\n        id\n      &#125;\n    &#125;)\n&#125;\n\n&#x2F;&#x2F; 准备数据\nconst textList &#x3D; [\n  &#39;@[]&#39;, &#x2F;&#x2F; 不匹配\n  &#39;@[123]&#39;, &#x2F;&#x2F; 不匹配\n  &#39;@asd[133]&#39;, &#x2F;&#x2F; 匹配\n  &#39;@阿里巴巴(杭州)(西湖)[546789][12113][12113][12113][12113][12113][12113]&#39;, &#x2F;&#x2F; 匹配\n  &#39;@阿里巴巴(杭州)(西湖)[12113]&#39;, &#x2F;&#x2F; 匹配\n  &#39;@阿里巴巴[444]&#39; &#x2F;&#x2F; 匹配\n]\n\n&#x2F;&#x2F; 处理\nconst formatTextList &#x3D; getFormatTextList(textList)\n\n&#x2F;&#x2F; 打印结果\nconsole.log(formatTextList)\n\n方法二在解决问题之前先了解一下贪婪匹配模式和惰性匹配模式。\n\n\n\n\n\n\n\n\n\n正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。\n贪婪匹配模式\n&quot;&#x2F;(.*at)&#x2F;&quot; &#x3D;&gt; The fat cat sat on the mat. \n\n贪婪匹配模式\n&quot;&#x2F;(.*?at)&#x2F;&quot; &#x3D;&gt; The fat cat sat on the mat. \n基于惰性匹配模式，我们用代码来实现一下\n&#x2F;&#x2F; 确定处理函数\nconst getFormatTextList &#x3D; (textList) &#x3D;&gt; &#123;\n  const regex &#x3D; &#x2F;\\@(.+?)\\[(\\d+)\\]&#x2F;\n  return textList\n    .filter((item) &#x3D;&gt; regex.test(item))\n    .map((item) &#x3D;&gt; &#123;\n      const [_, name, id] &#x3D; item.match(regex)\n      return &#123;\n        name,\n        id\n      &#125;\n    &#125;)\n&#125;\n\n&#x2F;&#x2F; 准备数据\nconst textList &#x3D; [\n  &#39;@[]&#39;, &#x2F;&#x2F; 不匹配\n  &#39;@[123]&#39;, &#x2F;&#x2F; 不匹配\n  &#39;@asd[133]&#39;, &#x2F;&#x2F; 匹配\n  &#39;@阿里巴巴(杭州)(西湖)[546789][12113][12113][12113][12113][12113][12113]&#39;, &#x2F;&#x2F; 匹配\n  &#39;@阿里巴巴(杭州)(西湖)[12113]&#39;, &#x2F;&#x2F; 匹配\n  &#39;@阿里巴巴[444]&#39; &#x2F;&#x2F; 匹配\n]\n\n&#x2F;&#x2F; 处理\nconst formatTextList &#x3D; getFormatTextList(textList)\n\n&#x2F;&#x2F; 打印结果\nconsole.log(formatTextList)\n\n\n\n\n\n","slug":"正则案例4","date":"2020-05-28T00:00:03.000Z","categories_index":"拓展","tags_index":"正则","author_index":"ZV"},{"id":"3f8553456a916ac0bd007eb93cc17e0f","title":"正则案例3","content":"需求提取字符串中的指定片段\n处理前\nconst text &#x3D; &#96;1234@Chesh我ire我 f我（qegqg3(2604)  @Cheshire fqegqg3(2604)@(111)(111)(123)Asdasdasdasdasd@1asd(111)@1asd(111)@1asd(111)@张&#x3D;阿萨德-阿1(111)(111)(123)Asdasdasdasdasd@1asd(111)@1asd(111)@张&#x3D;阿萨德(0)1111@张&#x3D;阿萨德-阿1(111)(111)(123)Asdasdasdasdasd@1asd(111)@1asd(111)@1asd(111)@张&#x3D;阿萨德-阿1(111)(111)(123)Asdasdasdasdasd@1asd(111)@1asd(111)   @辉煌（……！&amp;（*……*（！……（&amp;）（E(111)&#96;\n\n处理后\n[\n  &#39;@Chesh我ire我 f我（qegqg3(2604)&#39;,\n  &#39;@Cheshire fqegqg3(2604)&#39;,\n  &#39;@(111)(111)(123)&#39;,\n  &#39;@1asd(111)&#39;,\n  &#39;@1asd(111)&#39;,\n  &#39;@1asd(111)&#39;,\n  &#39;@张&#x3D;阿萨德-阿1(111)(111)(123)&#39;,\n  &#39;@1asd(111)&#39;,\n  &#39;@1asd(111)&#39;,\n  &#39;@张&#x3D;阿萨德(0)&#39;,\n  &#39;@张&#x3D;阿萨德-阿1(111)(111)(123)&#39;,\n  &#39;@1asd(111)&#39;,\n  &#39;@1asd(111)&#39;,\n  &#39;@1asd(111)&#39;,\n  &#39;@张&#x3D;阿萨德-阿1(111)(111)(123)&#39;,\n  &#39;@1asd(111)&#39;,\n  &#39;@1asd(111)&#39;,\n  &#39;@辉煌（……！&amp;（*……*（！……（&amp;）（E(111)&#39;\n]\n\n解决&#x2F;&#x2F; 确定处理函数\nconst getFormatText &#x3D; text &#x3D;&gt; &#123;\n  const regex &#x3D; &#x2F;\\@[^(]*(?&#x3D;\\()((\\(\\d*\\)))+&#x2F;gm\n  return text.match(regex)\n&#125;\n\n&#x2F;&#x2F; 准备数据\nconst text &#x3D; &#96;1234@Chesh我ire我 f我（qegqg3(2604)  @Cheshire fqegqg3(2604)@(111)(111)(123)Asdasdasdasdasd@1asd(111)@1asd(111)@1asd(111)@张&#x3D;阿萨德-阿1(111)(111)(123)Asdasdasdasdasd@1asd(111)@1asd(111)@张&#x3D;阿萨德(0)1111@张&#x3D;阿萨德-阿1(111)(111)(123)Asdasdasdasdasd@1asd(111)@1asd(111)@1asd(111)@张&#x3D;阿萨德-阿1(111)(111)(123)Asdasdasdasdasd@1asd(111)@1asd(111)   @辉煌（……！&amp;（*……*（！……（&amp;）（E(111)&#96;\n\n&#x2F;&#x2F; 处理\nconst formatText &#x3D; getFormatText(text)\n\n&#x2F;&#x2F; 打印结果\nconsole.log(formatText)\n\n","slug":"正则案例3","date":"2020-05-28T00:00:02.000Z","categories_index":"拓展","tags_index":"正则","author_index":"ZV"},{"id":"4768ff81dbae1fb5fcd14071ae0c610b","title":"正则案例2","content":"需求提取网址中的指定片段\n处理前\nlet url1 &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:8123&#x2F;#&#x2F;monitoring&#39;\nlet url2 &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:8123&#x2F;#&#x2F;monitoring?id&#x3D;1&#39;\n\n处理后\n&#39;monitoring&#39;\n&#39;monitoring&#39;\n\n解决&#x2F;&#x2F; 确定正则\nlet regex &#x3D; &#x2F;\\w+\\W+(\\d+\\.?)&#123;4&#125;\\W\\d+\\W+(\\w+)(\\?.+)?&#x2F;g\n&#x2F;&#x2F; 准备数据\nlet url1 &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:8123&#x2F;#&#x2F;monitoring&#39;\nlet url2 &#x3D; &#39;http:&#x2F;&#x2F;127.0.0.1:8123&#x2F;#&#x2F;monitoring?id&#x3D;1&#39;\n&#x2F;&#x2F; 处理\nlet result1 &#x3D; url1.replace(regex, (match, p1, p2) &#x3D;&gt; &#123;\n\treturn p2\n&#125;)\nlet result2 &#x3D; url2.replace(regex, (match, p1, p2) &#x3D;&gt; &#123;\n\treturn p2\n&#125;)\n&#x2F;&#x2F; 打印结果\nconsole.log(result1)\nconsole.log(result2)\n\n\n\n\n\n","slug":"正则案例2","date":"2020-05-28T00:00:01.000Z","categories_index":"拓展","tags_index":"正则","author_index":"ZV"},{"id":"b6af9bdc373dfe5e85cac266ab9c67da","title":"正则案例1","content":"需求提取字符串中数据处理成数组嵌套对象的格式\n处理前\nlet str &#x3D; &#96;1.辅导\n如何发挥每位员工都有独特的潜力？辅导是催化剂，学会辅导便能催化潜力。\nNeed a unique potential? Mastering coaching skill can catalyze people’s potential.\n\n\n2.培养员工\n员工是组织的最大资产，培养员工，就可以成就团队，繁荣组织。\nDevelop your employees to make your team and organization successful.\n\n\n\n3.沟通难题\n冲突是了解对方、了解自己的途径。通过无伤害式回应保护自己的同时保护对手。\nConflict is to understand. Communication is to protect.\n\n\n4.多元化\n多元化是一段追寻价值与尊重的旅程，管理者需换位思考去建立多元化联系。\nAlter your mindset and build diversified connection to show your value and respect.\n\n\n\n5.反馈要领\n最有效的反馈是提出新挑战，鼓励员工学习和成长，如导师般持续沟通与激励。\nEffective feedback is the key to greater results and higher engagement.\n\n\n6.全球合作 APP里面叫全球协作\n你目前或许不需要全球化协作，但不能不具备全球化视野去思考与解决问题。\nGlobal collaboration might not be on your plate now, but the vision is a must.\n\n7.招聘\n你做的任何事都取决于你招聘的员工。学习如何招聘会让你的职业生涯会更成功。\nYou are who you hire. Recruiting the right talent is vital to thriving in your field.\n\n\n8.   领导员工\n领导员工可以表达自己的价值观，构建组织，让员工充实生活，并实现组织目标。\nLead it right, you’ll create a culture in which peoples’ work make their hearts sing.\n\n \n9.   利用您的人际网络\n人际网络的价值不单是解决问题，更有你与其他人之间的无形却强大的人际关系。\nNetworking not only solves problems, it also opens up your vision and opportunities.\n\n \n10. 管理您的上司\n你与上司的关系对你的成败至关重要，对上司越了解，越有利于把事情做到最好。\nYou and your boss are on the same boat. To succeed, you as well be on the same page.\n\n \n11. 会议管理\n会议越高效，结果就越好。这是你作为领导者脱颖而出的好机会。\nShort and efficient meetings help you go a longer way and achieve greater success.\n\n \n12. 绩效评估\n绩效评估让员工了解公司的期望和对他们工作表现的反馈，并鼓励员工积极改进。\nPerformance review should be a motivation that elicits the staffs’ improvements. \n\n \n13. 说服他人\n你的每个梦想都与他人相关，需通过他人实现。说服他人的能力是你成功的标志。\nYou always need a hand. How you persuade others determines how likely you’ll succeed.\n\n \n14. 留住关键员工\n以你希望的领导者对待你的方式对待你的员工，这才能把你的最佳员工留在身边。\nTreating your employees the way you want to be treated keeps the best talent around. \n\n \n15. 团队组建\n寻找性格适合的人确实重要，但你更应寻找的是愿意和渴望学习并分享知识的人。\nLook not only for good spirit, but also for those who are eager to learn and share.\n\n \n16. 团队管理\n培养信任与团队认同感，简化政策，鼓励开放交流，促进协作，公允的绩效奖励。\nFoster trust and set down clear regulations to create strong bonds between members.\n\n\n17. 预算编制\n预算编制会给你挑战，但也给你一个实现目标的机会。通过编制预算来掌控未来。\nBudgeting is how you measure the resources you have in hand to control the future.\n\n \n18. 撰写立项报告\n立项报告涉及确定战略机会，以及确定各方可享有的好处与财务收益的挂钩。\nA strong business case sets a clear view of your strategic opportunities and returns. \n\n \n19. 编写商业计划书\n商业计划书是制定满足未满足的需求的战略，并证明团队的制胜能力与策应能力。\nUse your business plan to pinpoint unmet customer needs and how you’ll fulfill them.\n\n \n20. 变革管理\n周围的变化是永恒且不可避免的，但可通过变革以使自己保持竞争力并正确前进。\nChange is eternal. Knowing how to manage it keeps you on the top of your game.\n\n21. 危机管理\n危机管理是一个不断学习的过程，如遇危机请冷静并开放的发掘新机遇与新能力。\nIn the light of crisis, never stop learning and keep a clear mind for new breaks. \n\n \n22. 以客户为中心\n你若认真倾听客户，他们便会反过来帮助你，二者是相互依存，协作双赢。\nPondering upon the true needs of your customers builds you a win-win relationship.\n\n \n23. 决策\n决策不是容易的事情，但若你了解决策的陷阱和复杂性，就可以提高成功的机会。\nSee through the complexity of decision making, you will make better decisions.\n\n \n24. 授权\n授权意味着放手，信任并赋予责任，提供支持与辅导，监督进度，但让员工主导。\nGranting others trust and responsibilities are the key instruments of delegating.\n\n \n25. 财务概要\n我们不想生活在靠预感做决策的世界，在财务领域的一切都是可知的，可获得的。\nNowadays, finance is how we elaborate on what we can deliver and what we want.\n\n \n26. 设定目标\n确定目标与价值观，坚定愿景并用语言表达，确定短期与长期的行动目标与路径。\nThink it through then put your goals down into words and transform them into actions.\n\n \n27. 创新和创造力\n你无法控制创新的灵光何时闪现。但创意的过程可以由你管理、培养和提升。\nYou can’t control when the bulb lights up, but the action afterwards is up to you. \n\n\n28. 实施创新\n要不断尝试并持续收集反馈，在过程中不断改进计划，尝试并探索做事的新方法。\nStay hungry, stay innovative. There&#39;s no a bed of roses in business. \n\n \n29. 营销精要\n向营销专家那样思考，你可以更好了解利益相关者要什么，以及你怎样帮助他们。\nThink like an expert, what do the stakeholders want and how you can carry them out.\n\n \n30. 谈判\n我需要理解他们，他们也需要理解我，我们需要弄清楚我们之间能达成什么交易。\nKeep in mind what our ultimate goals are, and how we can reach a deal on it. \n\n\n31. 绩效衡量\n绩效衡量的核心目标是制定真正有用的标准，而不是展示你已衡量过这些绩效。\nPerformance measurement supports accountability and helps demonstrate success.\n\n32. 流程优化\n处理公司流程改进的最重要的方法是下定改进流程的决心。决心是第一步。\nSet forth your commitment to improve your process and deliver greater value. \n\n\n33. 项目管理\n运营良好的项目是企业发展和创新的动力，是学习复制推广经验的机会。\nAll project is an innovative journey and the impact may last longer than you think.\n\n\n34. 战略思维\n定义你的经营方式并能让你脱颖而出的理念是什么？这才是战略思维的核心问题。\nWhat makes you stand out? Strategic thinking is your unique take on the future.\n\n\n35. 战略规划与执行\n执行就是让每个人按照既定的战略采取行动。战略在持续演变，组织要及时行动。\nAs a manager you have to lead your unit to connect their actions to the strategy. \n\n\n36. 职业生涯管理\n成功，最大障碍是害怕失败和被拒绝，需靠信仰和勇气下的激情、行动与坚持。\nPursuing your dream is challenging. Thus, you should uphold your courage and grid.\n\n\n37. 职业道德\n忠诚代表一种价值观，有一些方法可以帮你系统、高效且公平地应对伦理挑战。\nEthical challenges can be handled fairly and efficiently via various ways.\n\n\n38. 演讲技巧\n演讲技能让人在任何场合或做的每件事中，都有感染性的自信和内驱力。\nBuilding up presentation skill also strengthens your self-confidence wherever you go.\n\n\n39. 压力管理\n参与你热爱的活动，并不只是让你拥有好心情，这还是让你取得高绩效的好策略。\nWhat builds great resiliency is the ability to engage in activities that bring us joy.\n\n\n40. 时间管理\n时间管理就是严于律己并保持专注和分清轻重缓急，能让你充实且快乐做好事情。\nDiscipline, focus and prioritizing are the three pillars of wise time management. \n\n\n41. 写作技巧\n了解你的受众以创造吸引力。在明确目的下思考、组织、起草、修改及润饰文稿。\nUnderstand your audience and craft your words carefully to fully convey your thought.&#96;\n\n处理后\n[&#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;辅导&quot;,&quot;docZh&quot;:&quot;如何发挥每位员工都有独特的潜力？辅导是催化剂，学会辅导便能催化潜力。&quot;,&quot;docEn&quot;:&quot;Need a unique potential? Mastering coaching skill can catalyze people’s potential.&quot;&#125;,&#123;&quot;id&quot;:&quot;2&quot;,&quot;name&quot;:&quot;培养员工&quot;,&quot;docZh&quot;:&quot;员工是组织的最大资产，培养员工，就可以成就团队，繁荣组织。&quot;,&quot;docEn&quot;:&quot;Develop your employees to make your team and organization successful.&quot;&#125;]\n\n解决&#x2F;&#x2F; 确定正则\nlet regex &#x3D; &#x2F;(\\d&#123;1,2&#125;)\\.\\s*(.+)\\n(.+)\\n(.+)&#x2F;g\n&#x2F;&#x2F; 创建空数组\nlet arr &#x3D; []\n&#x2F;&#x2F; 处理\nstr.replace(regex, (match, p1, p2, p3, p4) &#x3D;&gt; &#123;\n    let item &#x3D; &#123;\n        id: p1,\n        name: p2,\n        docZh: p3,\n        docEn: p4\n    &#125;\n    arr.push(item)\n&#125;)\n&#x2F;&#x2F; 打印结果\nconsole.log(JSON.stringify(arr))\nconsole.log(arr)\n\n","slug":"正则案例1","date":"2020-05-28T00:00:00.000Z","categories_index":"拓展","tags_index":"正则","author_index":"ZV"},{"id":"82b2c0d9626305e58241dff00b52469b","title":"Better-Scroll使用小例子","content":"&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n  &lt;title&gt;Document&lt;&#x2F;title&gt;\n  &lt;style&gt;\n    * &#123;\n      padding: 0;\n      margin: 0;\n      text-decoration: none;\n    &#125;\n\n    .wrapper &#123;\n      width: 100vw;\n      height: 100vh;\n      overflow: hidden;\n    &#125;\n\n    .box &#123;\n      height: 10vh;\n      box-sizing: border-box;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      border-bottom: 1px solid black;\n      font-size: 24px;\n    &#125;\n  &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n  &lt;div&gt;\n    &lt;div class&#x3D;&quot;wrapper&quot;&gt;\n      &lt;div class&#x3D;&quot;box-list&quot;&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 01&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 02&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 03&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 04&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 05&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 06&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 07&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 08&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 09&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 10&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 11&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 12&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 13&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 14&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 15&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 16&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 17&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 18&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 19&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;box&quot;&gt;BOX 20&lt;&#x2F;div&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script src&#x3D;&quot;.&#x2F;bscroll.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script&gt;\n    let wrapper &#x3D; document.querySelector(&#39;.wrapper&#39;)\n    let scroll &#x3D; new BScroll(wrapper, &#123;\n      scrollX: true,\n      scrollY: true,\n      probeType: 3,\n    &#125;)\n\n    scroll.on(&#39;scroll&#39;, function () &#123;\n      console.log(&#39;on scroll&#39;)\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n\n","slug":"Better-Scroll使用小例子","date":"2020-04-03T00:00:00.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"ZV"},{"id":"be2d23ba3555cc49cd98054b66cb7fb6","title":"数学归纳法","content":"对于类似这种无穷数列的问题，我们通常可以采用数学归纳法（Mathematical Induction）来证明。\n在数论中，数学归纳法用来证明任意一个给定的情形都是正确的，也就是说，第一个、第二个、第三个，一直到所有情形，概不例外。\n数学归纳法的一般步骤是这样的：\n\n证明基本情况（通常是 n = 1 的时候）是否成立；\n假设 n = k − 1 成立，再证明 n = k 也是成立的（k 为任意大于 11 的自然数）\n\n迭代 VS 数学归纳法const TOTAL_GRID &#x3D; 64\n\n&#x2F;&#x2F; 迭代法\nconst iterativeFunc &#x3D; totalGrid &#x3D;&gt; &#123;\n  let currentGrid &#x3D; 0\n  let sum &#x3D; 0\n  while (currentGrid &lt; totalGrid) &#123;\n    sum +&#x3D; 1 * Math.pow(2, currentGrid)\n    currentGrid +&#x3D; 1\n  &#125;\n  return sum\n&#125;\n&#x2F;&#x2F; 数学归纳法\nconst inductionFunc &#x3D; totalGrid &#x3D;&gt; Math.pow(2, totalGrid) - 1\n\nconst res1 &#x3D; iterativeFunc(TOTAL_GRID)\nconst res2 &#x3D; inductionFunc(TOTAL_GRID)\n","slug":"数学归纳法","date":"2020-03-31T00:00:00.000Z","categories_index":"基础","tags_index":"数学","author_index":"ZV"},{"id":"bb11073ba74dcf1394b9c67790d7c20c","title":"R 语言日期与时间","content":"获取当前的日期和时间在编程中，为了获得当前的日期和时间，有两个常用的函数，这两个函数以 Sys 开头，返回的时间受到操作系统区域设置的影响，因此，返回的时间采用本地格式，符合本地的阅读习惯：\n&gt; Sys.Date()\n[1] &quot;2020-03-18&quot;\n&gt; class(Sys.Date())\n[1] &quot;Date&quot;\n\n&gt; Sys.time()\n[1] &quot;2020-03-18 09:07:53 CST&quot;\n&gt; class(Sys.time())\n[1] &quot;POSIXct&quot; &quot;POSIXt&quot;\n\nR 还有一个函数 date()，用于返回当前时间对应的文本\n&gt; date()\n[1] &quot;Wed Mar 18 09:12:28 2020&quot;\n\n文本 &gt;&gt; 日期和时间\nas.Date() 把文本转换为日期\nas.Date(x, format)\n\nformat 参数用于指定输入的格式，常用的日期格式符号是：\n\n%y：两位数字表示的年份（00-99），不带世纪，例如，数值是 18，格式%y，表示 2018 年 \n%Y：四位数字表示的年份（0000-9999）                                              \n%m：两位数字的月份，取值范围是 01-12，或 1-12                                    \n%d：月份中的天，取值范围是 01-31                                                 \n%e：月份中的天，取值范围是 1-31                                                  \n%b：月份的缩写（Jan、Feb、Mar 等）                                               \n%B：月份的全名（January、February 、March 等）                                   \n%a：星期的缩写（Mon、Tue、Wed、Thur、Fri、Sat、Sun）                             \n%A：星期的全名（Monday、Tuesday、Wednesday 等）  \n\ndate_vec &lt;- c(&quot;2020-01-01&quot;, &quot;2020-12-31&quot;)\ndate_vec_format &lt;- as.Date(date_vec, format &#x3D; &quot;%Y-%m-%d&quot;)\n\nstrptime() 解析日期\n函数strptime()，是string parse time的简称，返回POSIXlt日期。在解析日期时，必须指定文本和日期对应的位置，日期的格式使用%+字母来指定。\nformat(x, format &#x3D; &quot;&quot;, tz &#x3D; &quot;&quot;)\n\n参数tz是时区（time zone），默认值是空，在解析时，如果不指定时区，R 会调用 Sys.timezone\n日期格式和 format()函数相同，常用的时间格式符号是：\n\n%H： 小时（24 小时制） \n%I： 小时（12 小时制） \n%p： 对于 12 小时制，指定上午（AM）或下午（PM） \n%M： 分钟 \n%S： 秒 \n\ncur_date &lt;- date()\ncur_date_parse &lt;- strptime(current_date, format &#x3D; &quot;%a %b %d %H:%M:%S %Y&quot;)\n\n\n\n日期和时间 &gt;&gt; 文本\nformat() 把日期转换为文本\n对日期进行格式化，转换为可读的文本，format()函数的定义是：\nformat(x, format &#x3D; &quot;&quot;, tz &#x3D; &quot;&quot;)\n\nx 是日期参数，format是输出的格式，tz是时区，该函数按照指定的格式输出文本：\ntoday &lt;- Sys.Date()\nmydate &lt;- format(today,format&#x3D;&#39;%Y-%m-%d&#39;)\n\nstrftime()格式化日期\n函数strftime()，是string formated time的简称，用于把时间转换为字符串\nstrptime(x, format, tz &#x3D; &quot;&quot;)\n\n该函数和format()函数的功能和使用方式几乎完全相同。\ntoday &lt;- Sys.Date()\nmydate &lt;- strftime(today,format&#x3D;&#39;%Y-%m-%d&#39;)\n\n\n\n日期的比较由于POSIXct类是以秒为单位来计算时间，Date类是以天为单位类计算日期，这意味着可以在日期值上执行比较运算和算术运算：\n\n将数字和Date类相加，增加或减少相应的天数\n将数字和POSIXct类相加，增加或减少相应的秒数\n\n\n时间和数字相加\n时间以秒为单位\n&gt; time1 &lt;- Sys.time()\n&gt; print(time1)\n[1] &quot;2018-05-08 13:16:36 CST&quot;\n&gt; print(time1+60*60)\n[1] &quot;2018-05-08 14:16:36 CST&quot;\n\n日期以天为单位\n&gt; date1 &lt;- Sys.Date()\n&gt; print(date1)\n[1] &quot;2018-05-08&quot;\n&gt; print(date1+1)\n[1] &quot;2018-05-09&quot;\n\n时间比较\n由于Date类和POSIXct类实际上都是一个整数，可以直接比较大小\ndate1 &lt;- as.Date(&#39;2018-01-01&#39;)\ndate2 &lt;- as.Date(&#39;2018-02-01&#39;)\nif (date2 &gt; date1)\n  print (&#39;gt&#39;)\n\n\n\n总结格式转换\n\n\n文本 &gt;&gt; 日期和时间\n日期和时间 &gt;&gt; 文本\n\n\n\nas.Date() 返回Date类型\nformat()\n\n\nstrptime() 返回 POSIXct类型\nstrftime()\n\n\n\n\n\n\n\n\n\n\n\nR 学习 第八篇：日期和时间\n","slug":"R语言日期与时间","date":"2020-03-18T00:00:00.000Z","categories_index":"拓展","tags_index":"R","author_index":"ZV"},{"id":"7c42f8de2051f2a0424b2125ac8f5fc7","title":"R 语言知识点杂记","content":"数据类型\nVectors (one dimensional array): can hold numeric, character or logical values. The elements in a vector all have the same data type.\nMatrices (two dimensional array): can hold numeric, character or logical values. The elements in a matrix all have the same data type.\nData frames (two-dimensional objects): can hold numeric, character or logical values. Within a column all elements have the same data type, but different columns can be of different data type.\nLists: ‘As opposed to vectors, lists can hold components of different types, just as your to-do lists can contain different categories of tasks. This chapter will teach you how to create, name, and subset these lists.’\n\nR 语言的标准差当我们按照课本里的公式去实现一个求标准差的函数时大概是这样的\nget_sd &lt;- function(vec) &#123;\n  square_sum &lt;- 0\n  vec_length &lt;- length(vec)\n  vec_mean &lt;- mean(vec)\n  for (item in vec) &#123;\n    square_sum &lt;- square_sum + (item - vec_mean) ^ 2\n  &#125;\n  vec_sd &lt;- sqrt(square_sum &#x2F; vec_length)\n  return(vec_sd)\n&#125;\n\n但是当我们使用 R 语言中自带的 sd函数计算标准差的时候答案却不太一样\n测试数据 num_vec &lt;- c(1, 2, 3, 4)\n测试结果\nget_sd(num_vec)\n# [1] 1.118034\nsd(num_vec)\n# [1] 1.290994\n\n那么问题到底出现在哪一个环节呢\n一通 Google 后在 Standard Deviation in R Seems to be Returning the Wrong Answer - Am I Doing Something Wrong?找到了答案\n意思大致是说 R语言中内建的 sd函数计算的是样本标准差而我们书本里教的则是整体标准差\n样本标准差的时候分母是n-1 而整体标准差的分母则是n\n分母的差别造成了两次实验结果的差异\n\n\n\n\n\n\n\n\n\n为什么样本方差（sample variance）的分母是 n-1？ - 张英锋的回答 - 知乎\n标准差和方差\nR 语言的返回值\nR 语言中 return 本身就是一个函数，所以必须使用 return(...) 的方式，括号不能省略；这意味着显式返回变成一种函数调用，可能降低程序运行效率。\n不使用 return 也可以提供返回值，所以 R 语言的普遍习惯用法是避免显式调用 return()。\n如果显式调用 return() 可以使得函数的结构更加清楚，那就尽管调用吧，没有问题。\n\n\n\n\n\n\n\n\n\n\n参考资料：StackOverflow - Explicitly calling return in a function or not\nNA 与 NULL 的区别在 R 语言中，缺失值用 NA表示，空值用NULL表示。初学者在学习 R 语言时，一般都会被这两者弄糊涂，常常错误地把这两者视为等价的。\n\n\n\n\n\n\n\n\n\nR 语言中”NA”与”NULL”的区别\nlibrary() 与 require() 的区别library()和require()都可以载入包，但二者存在区别。\n在一个函数中，如果一个包不存在，执行到 library 将会停止执行，require 则会继续执行。\nrequire 将会根据包的存在与否返回TRUE或者FALSE\n\n\n\n\n\n\n\n\n\nWhat is the difference between require() and library()?\napply 函数族\n\nlapply\n\napply function over list or vector\noutput = list\n\n\nsapply\n\napply function over list or vector\ntry to simplify list to array\n\n\nvapply\n\napply function over list or vector\nexplicitly specify output format\n\n\n\n\n\n\n\n\n\n\n\n\nA brief introduction to “apply” in R\n掌握 R 语言中的 apply 函数族\n碰到的函数\n\n\n函数\n功能\n\n\n\nrnorm\n生成一系列的随机数\n\n\nstrsplit\n分割字符串\n\n\nsd\n计算样本标准差\n\n\nargs\n获得函数参数\n\n\nsample\n对数据进行抽样\n\n\ngsub\n用于对的删减、增补、替换和切割\n\n\nidentical\n判断两个对象是否相等\n\n\ncat\n连接并输出\n\n\nrunif\n生成均匀分布随机数\n\n\n\n\n\n\n数字相关函数\n\n\n函数\n功能\n\n\n\nabs\n取绝对值\n\n\nsum\n求和\n\n\nmean\n求平均住\n\n\nround\n四舍五入\n\n\nfloor\n向下取整\n\n\nceiling\n向上取整\n\n\ntrunc\n向零的方向截取\n\n\nsignif\n保留有效数字\n\n\n数据相关函数\n\n\n函数\n功能\n\n\n\nseq\nGenerate sequences, by specifying the from, to, and by arguments.\n\n\nrep\nReplicate elements of vectors and lists.\n\n\nsort\nSort a vector in ascending order. Works on numerics, but also on character strings and logicals.\n\n\nrev\nReverse the elements in a data structures for which reversal is defined.\n\n\nstr\nDisplay the structure of any R object.\n\n\nappend\nMerge vectors or lists.\n\n\nis.*()\nCheck for the class of an R object.\n\n\nas.*()\nConvert an R object from one class to another.\n\n\nunlist\nFlatten (possibly embedded) lists to produce a vector.\n\n\n正则表达式相关函数\n\n\n函数\n功能\n\n\n\ngrepl\nwhich returns TRUE when a pattern is found in the corresponding character string\n\n\ngrep\nwhich returns a vector of indices of the character strings that contains the pattern\n\n\nsub\nreplace first match\n\n\ngsub\nreplace all matches\n\n\n如何安装 XLConnect\n安装 JDK\n\n配置 JAVA_HOME\nSys.setenv(JAVA_HOME&#x3D;&#39;D:\\\\Program Files\\\\Java\\\\jre1.8.0_202&#39;)\n\n安装 XLConnect\ninstall.packages(&quot;XLConnect&quot;)\n\n\n\n\n\n","slug":"R语言知识点杂记","date":"2020-03-17T00:00:00.000Z","categories_index":"拓展","tags_index":"R","author_index":"ZV"},{"id":"f7ee095c73b7adf12560106c216e64a2","title":"移动Web开发","content":"\n运行在手机端的 Web页面（H5页面）\n跨平台\n基于Webview\n告别IE拥抱Webkit\n更好的适配和性能要求\n\n常见移动web适配方法PC\n960px / 1000px 居中\n盒子模型，定高，定宽\ndisplay:inline-block\n\n移动web\n定高，宽度百分比\nFlex布局\nMedia Query（媒体查询）\n\nMedia Query（媒体查询）@media 媒体类型 and (媒体特性) &#123;\n    &#x2F;*css样式*&#x2F;\n&#125;\n\n举个例子\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n        .inner &#123;\n            text-align: center;\n            color: white;\n            line-height: 100px;\n            font-size: 24px;\n        &#125;\n\n        .box .inner:nth-child(2n) &#123;\n            background: palegreen;\n        &#125;\n\n        .box .inner:nth-child(2n+1) &#123;\n            background: palevioletred;\n        &#125;\n\n        @media screen and (max-width: 320px) &#123;\n            .inner &#123;\n                width: 100%;\n            &#125;\n        &#125;\n\n        @media screen and (min-width: 321px) &#123;\n            .inner &#123;\n                width: 25%;\n                float: left;\n            &#125;\n        &#125;\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n    &lt;div class&#x3D;&quot;box&quot;&gt;\n        &lt;div class&#x3D;&quot;inner&quot;&gt;1&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;inner&quot;&gt;2&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;inner&quot;&gt;3&lt;&#x2F;div&gt;\n        &lt;div class&#x3D;&quot;inner&quot;&gt;4&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n\nrem 布局\n\n\n\n\n\n\n\n\nrem：font size of the root element\n\n字体单位：值根据html根元素大小而定，同样可以作为宽度高度等单位\n适配原理：将px替换成rem，动态修改html的font-size适配\n兼容性：IOS 6以上和Android 2.1以上，基本覆盖所有流行的手机系统\n\n使用流程使用设备：iPhone 6/7/8 \n切图：750px x 1334px 两倍图\n\n使用JS动态修改 html的 font-size\nfunction setFontSize() &#123;\n    &#x2F;&#x2F;得到手机屏幕的宽度\n    let htmlWidth &#x3D; document.documentElement.clientWidth || document.body.clientWidth;\n    &#x2F;&#x2F;得到html的Dom元素\n    let htmlDom &#x3D; document.getElementsByTagName(&#39;html&#39;)[0];\n    &#x2F;&#x2F;设置根元素字体大小\n    htmlDom.style.fontSize &#x3D; htmlWidth &#x2F; 10 + &#39;px&#39;;\n&#125;\nsetFontSize()\nwindow.addEventListener(&#39;resize&#39;, function (e) &#123;\n\tsetFontSize()\n&#125;)\n\n使用scss编写px转换成rem的函数\n@function px2rem($px) &#123;\n    $rem: 37.5px;\n    @return ($px&#x2F;$rem)+rem;\n&#125;\n\n愉快的编写样式代码喽\n.box &#123;\n    width: px2rem(100px);\n    height: px2rem(100px);\n    font-size: px2rem(24px);\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n参考：\n移动web开发适配秘籍Rem\n关于移动端适配，你必须要知道的\n","slug":"移动Web开发","date":"2019-12-25T00:00:00.000Z","categories_index":"前端","tags_index":"JavaScript,移动端,CSS","author_index":"ZV"},{"id":"37a029b7298934d10b895fa948d82730","title":"链表了解一下？","content":"&#x2F;&#x2F; 声明节点\nclass Node &#123;\n  constructor(value) &#123;\n    this.value &#x3D; value\n    this.next &#x3D; null\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 单链表\nclass SingleLinkedList &#123;\n  constructor() &#123;\n    this.head &#x3D; new Node(&#39;head&#39;)\n  &#125;\n  &#x2F;&#x2F; 末尾追加节点\n  append(value) &#123;\n    let currentNode &#x3D; this.head\n    while (currentNode.next !&#x3D;&#x3D; null) &#123;\n      currentNode &#x3D; currentNode.next\n    &#125;\n    let newNode &#x3D; new Node(value)\n    currentNode.next &#x3D; newNode\n    return newNode\n  &#125;\n  &#x2F;&#x2F; 根据value查找节点\n  findNodeByValue(value) &#123;\n    let currentNode &#x3D; this.head.next\n    while (currentNode !&#x3D;&#x3D; null &amp;&amp; currentNode.value !&#x3D;&#x3D; value) &#123;\n      currentNode &#x3D; currentNode.next\n    &#125;\n    return currentNode &#x3D;&#x3D;&#x3D; null ? -1 : currentNode\n  &#125;\n  &#x2F;&#x2F; 根据index查找节点\n  findNodeByIndex(index) &#123;\n    let currentNode &#x3D; this.head.next\n    let pos &#x3D; 0\n    while (currentNode !&#x3D;&#x3D; null &amp;&amp; pos !&#x3D;&#x3D; index) &#123;\n      currentNode &#x3D; currentNode.next\n      pos++\n    &#125;\n    return currentNode &#x3D;&#x3D;&#x3D; null ? -1 : currentNode\n  &#125;\n  &#x2F;&#x2F; 转化ArrayList\n  toArrayList() &#123;\n    let currentNode &#x3D; this.head.next\n    let arrayList &#x3D; []\n    while (currentNode !&#x3D;&#x3D; null) &#123;\n      arrayList.push(currentNode.value)\n      currentNode &#x3D; currentNode.next\n    &#125;\n    return arrayList\n  &#125;\n  &#x2F;&#x2F; 插入节点\n  insertAfter(newValue, value) &#123;\n    let prevNode &#x3D; this.findNodeByValue(value)\n    if (prevNode &#x3D;&#x3D;&#x3D; -1) &#123;\n      return -1\n    &#125; else &#123;\n      let newNode &#x3D; new Node(newValue)\n      newNode.next &#x3D; prevNode.next\n      prevNode.next &#x3D; newNode\n      return newNode\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 根据value查找value的前一个节点y\n  findPrevNodeByValue(value) &#123;\n    let currentNode &#x3D; this.head\n    while (currentNode.next !&#x3D;&#x3D; null &amp;&amp; currentNode.next.value !&#x3D;&#x3D; value) &#123;\n      currentNode &#x3D; currentNode.next\n    &#125;\n    return currentNode.next &#x3D;&#x3D;&#x3D; null ? -1 : currentNode\n  &#125;\n  &#x2F;&#x2F; 根据value删除节点\n  removeNodeByValue(value) &#123;\n    let prevNode &#x3D; this.findPrevNodeByValue(value)\n    if (prevNode &#x3D;&#x3D;&#x3D; -1) &#123;\n      return -1\n    &#125; else &#123;\n      prevNode.next &#x3D; prevNode.next.next\n      return this.toArrayList()\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 反转链表\n  reverse() &#123;\n    let currentNode &#x3D; this.head.next\n    let prevNode &#x3D; null\n    while (currentNode !&#x3D;&#x3D; null) &#123;\n      let nextNode &#x3D; currentNode.next\n      currentNode.next &#x3D; prevNode\n      prevNode &#x3D; currentNode\n      currentNode &#x3D; nextNode\n    &#125;\n    this.head.next &#x3D; prevNode\n    return this.toArrayList()\n  &#125;\n  &#x2F;&#x2F; 清空链表\n  clear() &#123;\n    this.head.next &#x3D; null\n    return this.toArrayList()\n  &#125;\n  &#x2F;&#x2F; 数组转单链表\n  static arrayToLinkedList(arrayList) &#123;\n    if (!Array.isArray(arrayList)) &#123;\n      return -1\n    &#125; else &#123;\n      let sll &#x3D; new SingleLinkedList()\n      for (let i &#x3D; 0; i &lt; arrayList.length; i++) &#123;\n        let value &#x3D; arrayList[i]\n        sll.append(value)\n      &#125;\n      return sll\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 环验证\n  checkCircle() &#123;\n    let slow &#x3D; this.head\n    let fast &#x3D; this.head.next\n    while (fast !&#x3D;&#x3D; null &amp;&amp; fast.next !&#x3D;&#x3D; null) &#123;\n      fast &#x3D; fast.next.next\n      slow &#x3D; slow.next\n      console.log(&#96;+++++++++++++++++++++++++&#96;)\n      console.log(&#39;slow&#39;, slow)\n      console.log(&#39;fast&#39;, fast)\n      console.log(&#96;+++++++++++++++++++++++++&#96;)\n      if (slow &#x3D;&#x3D; fast) return true\n    &#125;\n    return false\n  &#125;\n&#125;\n\nlet sll &#x3D; new SingleLinkedList()\nfor (let i &#x3D; 0; i &lt; 5; i++) &#123;\n  sll.append(&#96;num $&#123;i&#125;&#96;)\n&#125;\n&#x2F;&#x2F; console.log(sll.toArrayList())\n&#x2F;&#x2F; console.log(sll.findNodeByIndex(2))\n&#x2F;&#x2F; console.log(sll.findNodeByValue(&#39;num 3&#39;))\n&#x2F;&#x2F; console.log(sll.insertAfter(&#39;xxx&#39;, &#39;num 3&#39;))\n&#x2F;&#x2F; console.log(sll.removeNodeByValue(&#39;num 1&#39;))\n&#x2F;&#x2F; console.log(SingleLinkedList.arrayToLinkedList([4, 2, 3, 6, 7]))\n\n&#x2F;&#x2F; 环验证测试\nconsole.log(sll.checkCircle())\nlet n2 &#x3D; sll.findNodeByIndex(2)\nlet n4 &#x3D; sll.findNodeByIndex(4)\nn4.next &#x3D; n2\nconsole.log(sll.checkCircle())\n\n\n","slug":"链表了解一下？","date":"2019-12-25T00:00:00.000Z","categories_index":"基础","tags_index":"算法","author_index":"ZV"},{"id":"27dde8e157ab6a19ae6c30873f9e3622","title":"分析一下这段代码的时间复杂度","content":"let array &#x3D; new Array(10)\nlet len &#x3D; 10\nlet i &#x3D; 0\n\n&#x2F;&#x2F; 向数组中添加一个元素\nfunction add(element) &#123;\n    &#x2F;&#x2F; 数组空间不够了\n    &#x2F;&#x2F; 重新申请一个2倍大小的数组空间\n    if (i &gt;&#x3D; len) &#123;\n        &#x2F;&#x2F; 把原来array数组中的数据依次copy到new_array\n        let new_array &#x3D; new Array(len * 2)\n        for (let j &#x3D; 0; j &lt; len; j++) &#123;\n            new_array[j] &#x3D; array[j]\n        &#125;\n        &#x2F;&#x2F; new_array复制给array，array现在大小就是2倍len了\n        array &#x3D; new_array\n        len &#x3D; 2 * len\n    &#125;\n    &#x2F;&#x2F; 将element放到下标为i的位置，下标i加一\n    array[i] &#x3D; element\n    ++i\n&#125;\n\n分析：\n\n  当i &lt; len时，即i = 0,1,2...n-1的时候，不走for循环，所以这n次的时间复杂度都是O(1)\n  当i &gt;= len时，即i = n的时候，需要走for循环拷贝 array到new_array，所以这1次的时间复杂度是O(n)\n\n由此可知：\n\n最好情况时间复杂度(best case time complexity)为O(1)\n\n最坏情况时间复杂度(worst case time complexity)为O(n)\n\n平均情况时间复杂度(average case time complexity)\n\n方法一：$$\\frac{1+1+…+1+n}{n+1}=\\frac{2n}{n+1}$$所以时间复杂度为O(n)\n注：1+1+...+1中有n个1\n\n方法二（加权平均法，也称期望）：$$1\\frac{1}{n+1}+1\\frac{1}{n+1}+…+1\\frac{1}{n+1}+n\\frac{1}{n+1}=\\frac{2n}{n+1}$$所以时间复杂度为O(n)\n注：1*(1/n+1)+1*(1/n+1)+...+1*(1/n+1)中有n个1*(1/n+1)\n\n方法三（均摊时间复杂度）：\n前 n 个操作复杂度都是 O(1)，第 n+1 次操作的复杂度是 O(n)，所以把最后一次的复杂度分摊到前 n 次上，那么均摊下来每次操作的复杂度为 O(1)\n\n\n\n\n","slug":"分析一下这段代码的时间复杂度","date":"2019-12-24T00:00:00.000Z","categories_index":"基础","tags_index":"算法","author_index":"ZV"},{"id":"af499e5c88a505a2fc70dcdaa2ef43a0","title":"我的 Prettier 设置","content":"在项目根目录中添加.prettierrc\n&#123;\n  &quot;arrowParens&quot;: &quot;avoid&quot;,\n  &quot;bracketSpacing&quot;: true,\n  &quot;htmlWhitespaceSensitivity&quot;: &quot;css&quot;,\n  &quot;insertPragma&quot;: false,\n  &quot;jsxBracketSameLine&quot;: true,\n  &quot;jsxSingleQuote&quot;: false,\n  &quot;printWidth&quot;: 140, \n  &quot;proseWrap&quot;: &quot;preserve&quot;,\n  &quot;quoteProps&quot;: &quot;as-needed&quot;,\n  &quot;requirePragma&quot;: false,\n  &quot;semi&quot;: false,\n  &quot;singleQuote&quot;: true,\n  &quot;tabWidth&quot;: 2,\n  &quot;trailingComma&quot;: &quot;none&quot;,\n  &quot;useTabs&quot;: false,\n  &quot;vueIndentScriptAndStyle&quot;: false\n&#125;\n\n如果想批量格式化文件，可以在package.json的scripts中添加\n&quot;scripts&quot;: &#123;\n  &quot;format&quot;: &quot;npx prettier .prettierrc --write \\&quot;src&#x2F;**&#x2F;*.&#123;ts,tsx&#125;\\&quot;&quot;,\n&#125;,\n\n","slug":"我的Prettier配置","date":"2019-12-19T00:00:00.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"ZV"},{"id":"78228826ae557ad432664d25fe0da568","title":"前端项目中的路径解析","content":"这里说的路径解析分两种\n\nWebpack打包配置项中的 alias\njsconfig.json中的 compilerOptions\n\nWebpack 打包配置项中的 alias相信很多人都很喜欢这个配置，因为在引用其他目录下的文件时，通过 ./../utils/tools.js这种写法显得特别的笨重。\n可是如果在配置了 alias这个属性就会好很多。\n这块不多说，文档讲的很详细了\n\n\n\n\n\n\n\n\n\n解析(resolve)\njsconfig.json中的 compilerOptions由于 Webpack的 alias配置你可能会在编写代码的时候遇到一些问题。\n因为通过 alias的方式编写的路径，你并不能通过转到定义访问到源文件。\n所以这个时候就需要 jsconfig.json来帮帮你了\n&#123;\n    &quot;compilerOptions&quot;: &#123;\n    &quot;baseUrl&quot;: &quot;.&quot;,\n    &quot;paths&quot;: &#123;\n        &quot;@&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;*&quot;],\n        &quot;comps&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;comps&#x2F;*&quot;],\n        &quot;config&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;config&#x2F;*&quot;],\n        &quot;pages&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;pages&#x2F;*&quot;],\n        &quot;resource&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;resource&#x2F;*&quot;],\n        &quot;styles&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;styles&#x2F;*&quot;],\n        &quot;utils&#x2F;*&quot;: [&quot;.&#x2F;src&#x2F;utils&#x2F;*&quot;]\n        &#125;\n    &#125;\n&#125;\n\n通过这个jsconfig.json你就可以解决因为使用 alias配置而导致的无法访问源文件问题了\n\n\n\n\n\n\n\n\n\nVSCode中的 jsconfig.json\nCreate React App无eject配置\n","slug":"前端项目中的路径解析","date":"2019-11-21T00:00:00.000Z","categories_index":"前端","tags_index":"JavaScript,Webpack","author_index":"ZV"},{"id":"7439e52dfcec57c3f9d78c17402f5261","title":"字符串的比较","content":"初次碰到 &#39;100&#39; &gt; &#39;99&#39; 这个问题的时候还是有点懵逼的，因为这种比较也不涉及之前所想的隐式类型转换，\n通过几次试验，发现JS中字符串与字符串比较是根据第一个不同的字符的ASCii值码进行比较的。\n举个例子\n&#39;100&#39; &gt; &#39;99&#39;\n&#x2F;&#x2F; 1. &#39;100&#39;.charCodeAt(0) &#x3D;&#x3D;&#x3D; 49\n&#x2F;&#x2F; 2. &#39;99&#39;.charCodeAt(0) &#x3D;&#x3D;&#x3D; 57\n&#x2F;&#x2F; 3. 49 &lt; 57 所以结果为 false\n\n在来一个有隐式转换的例子\n[&#39;100&#39;] &gt; 99\n&#x2F;&#x2F; 1. 对象类型与其他类型比较 对象类型会转换为原始值 [&#39;100&#39;] &#x3D;&#x3D;&gt; &#39;100&#39;\n&#x2F;&#x2F; 2. 字符串与数字类型比较，字符串会变为数字 &#39;100&#39; &#x3D;&#x3D;&gt; 100\n&#x2F;&#x2F; 3. 100 &gt; 99 所以结果为 true\n\n\n\n","slug":"字符串的比较","date":"2019-10-16T00:00:00.000Z","categories_index":"前端","tags_index":"JavaScript","author_index":"ZV"},{"id":"8551a057987c47b63b4bd98874d26a3d","title":"自定义Linux登录页面","content":"\n在 VSCode 中下载 ASCIIDecorator\n\n使用 ASCIIDecorator创建字符画 \n\n使用 vim或 nano打开 /etc/motd把上一步生成的字符画拷贝进来即可\n\n最后 \n\n\n","slug":"自定义Linux登录页面","date":"2019-09-04T00:00:00.000Z","categories_index":"运维","tags_index":"Linux","author_index":"ZV"},{"id":"3d3f2e4e9b33a8dce5a553e2cf7270fd","title":"GoAccess使用指北","content":"安装yum install goaccess\n\n启动\n跳转到 nginx/logs目录\n\n使用命令将report.html输出到 nginx/html目录下\n\n实时版本\ngoaccess access.log -o ..&#x2F;html&#x2F;report.html --log-format&#x3D;COMBINED --real-time-html\n\n静态版本\ngoaccess access.log -o ..&#x2F;html&#x2F;report.html --log-format&#x3D;COMBINED\n\n\n\n配置 nginx.conf\n http &#123;\n    server &#123;\n        listen 1234;\n        location &#x2F;report.html &#123;\n            alias html&#x2F;report.html;\n        &#125;\n    &#125;\n&#125;\n\n最后打开xx.xxx.xxx.xx：1234/report.html就可以访问GoAccess了\n\n\n使用 crontabs 定时更新\n编写更新 goaccess的脚本\n#!&#x2F;bin&#x2F;bash\ngoaccess &#x2F;home&#x2F;nginx&#x2F;logs&#x2F;access.log -o &#x2F;home&#x2F;nginx&#x2F;html&#x2F;report&#x2F;index.html --log-format&#x3D;COMBINED\necho -e &quot;update success&quot;\n\nyum install crontabs安装 crontabs\n\ncrontab -e配置定时任务\n贴入以下配置，保存即可\n0 0 * * * &#x2F;common_shell&#x2F;update_goaccess.sh\n\n\n\n\n\n\n\n\n\n\n\n\nCRON可视化工具\nLinux/Mac Tutorial: Cron Jobs - How to Schedule Commands with crontab\n","slug":"GoAccess使用指北","date":"2019-08-27T00:00:00.000Z","categories_index":"运维","tags_index":"Nginx","author_index":"ZV"},{"id":"4f3559b97c389436f045f114bdd6b998","title":"Nginx 反向代理","content":"真实应用背景一台阿里云 ECS，一个域名\n需求emotionl.fun 的二级域名分别指向服务器的两个服务\n\n\n实现思路使用nginx的upstream控制上游服务器，用proxy_pass进行反向代理\n操作\n使用第一台 nginx 开启两个静态服务\n worker_processes 1;\n\nevents &#123;\n    worker_connections 1024;\n&#125;\n\nhttp &#123;\n    include mime.types;\n    default_type application&#x2F;octet-stream;\n    sendfile on;\n    keepalive_timeout 65;\n    gzip on;\n    gzip_min_length 1024;\n    gzip_comp_level 2;\n    gzip_types text&#x2F;plain text&#x2F;css application&#x2F;x-javascript application&#x2F;javascript application&#x2F;xml;\n    server &#123;\n        listen 4444;\n        location &#x2F; &#123;\n            alias test_website&#x2F;site1&#x2F;;\n        &#125;\n        location &#x3D; &#x2F;50x.html &#123;\n            root html;\n        &#125;\n        error_page 500 502 503 504  &#x2F;50x.html;\n    &#125;\n    server &#123;\n        listen 6666;\n        location &#x2F; &#123;\n            alias test_website&#x2F;site2&#x2F;;\n        &#125;\n        location &#x3D; &#x2F;50x.html &#123;\n            root html;\n        &#125;\n        error_page 500 502 503 504  &#x2F;50x.html;\n    &#125;\n&#125;\n\n使用第二台 nginx开启反向代理\n worker_processes 1;\n\nevents &#123;\n    worker_connections 1024;\n&#125;\n\nhttp &#123;\n    include mime.types;\n    default_type application&#x2F;octet-stream;\n    sendfile on;\n    keepalive_timeout 65;\n    upstream site1 &#123;\n        server 127.0.0.1:1234;\n    &#125;\n    upstream site2 &#123;\n        server 127.0.0.1:2342;\n    &#125;\n    server &#123;\n        listen 80;\n        server_name site1.emotionl.fun;\n        location &#x2F; &#123;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http:&#x2F;&#x2F;site1;\n        &#125;\n        location &#x3D; &#x2F;50x.html &#123;\n            root html;\n        &#125;\n        error_page 500 502 503 504  &#x2F;50x.html;\n    &#125;\n    server &#123;\n        listen 80;\n        server_name site2.emotionl.fun;\n        location &#x2F; &#123;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http:&#x2F;&#x2F;site2;\n        &#125;\n        location &#x3D; &#x2F;50x.html &#123;\n            root html;\n        &#125;\n        error_page 500 502 503 504  &#x2F;50x.html;\n    &#125;\n&#125;\n\n\n","slug":"Nginx反向代理","date":"2019-08-27T00:00:00.000Z","categories_index":"运维","tags_index":"Nginx","author_index":"ZV"},{"id":"e5fb6a3fd97ef95b02d7d5beaa06b7e3","title":"MongoDB 高级查询","content":"MongoDB 聚合管道使用聚合管道可以对集合中的文档进行变换和组合实际运用：表关联查询、数据的统计MongoDB 中使用 db.COLLECTION_NAME.aggregate([&#123;&#125;,...]) 方法来构建和使用聚合管道\nAggregation Pipeline Stages &amp; OperatorsStages 操作\n\n\n操作符 S\n描述\n\n\n\n$project\n修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档\n\n\n$match\n用于过滤数据，只输出符合条件的文档。$match 使用 MongoDB 的标准查询操作\n\n\n$limit\n用来限制 MongoDB 聚合管道返回的文档数\n\n\n$skip\n在聚合管道中跳过指定数量的文档，并返回余下的文档\n\n\n$group\n将集合中的文档分组，可用于统计结果\n\n\n$sort\n将输入文档排序后输出\n\n\n$lookup\n用以引入其它集合的数据 （表关联查询）\n\n\nOperators 运算符\n\n\nOperators\n描述\n\n\n\n$sum\n计算总和\n\n\n$avg\n计算平均值\n\n\n$min\n获取集合中所有文档对应值得最小值\n\n\n$max\n获取集合中所有文档对应值得最大值\n\n\n$push\n在结果文档中插入值到一个数组中\n\n\n$addToSet\n在结果文档中插入值到一个数组中，但不创建副本\n\n\n$first\n根据资源文档的排序获取第一个文档数据\n\n\n$last\n根据资源文档的排序获取最后一个文档数据\n\n\n\n\n\n\n\n\n\n\n\n管道操作符作为键，所对应的值叫做管道表达式例如&#123;$match:&#123;status:&quot;A&quot;&#125;&#125;，$match 称为管道操作符，而 status:&quot;A&quot;称为管道表达式每个管道表达式是一个文档结构，它是由字段名、字段值、和一些表达式操作符组成的\n数据模拟db.order.insert(&#123;&quot;order_id&quot;:&quot;1&quot;,&quot;uid&quot;:10,&quot;trade_no&quot;:&quot;111&quot;,&quot;all_price&quot;:100,&quot;all_num&quot;:2&#125;)\ndb.order.insert(&#123;&quot;order_id&quot;:&quot;2&quot;,&quot;uid&quot;:7,&quot;trade_no&quot;:&quot;222&quot;,&quot;all_price&quot;:90,&quot;all_num&quot;:2&#125;)\ndb.order.insert(&#123;&quot;order_id&quot;:&quot;3&quot;,&quot;uid&quot;:9,&quot;trade_no&quot;:&quot;333&quot;,&quot;all_price&quot;:20,&quot;all_num&quot;:6&#125;)\ndb.order_item.insert(&#123;&quot;order_id&quot;:&quot;1&quot;,&quot;title&quot;:&quot;商品鼠标 1&quot;,&quot;price&quot;:50,num:1&#125;)\ndb.order_item.insert(&#123;&quot;order_id&quot;:&quot;1&quot;,&quot;title&quot;:&quot;商品键盘 2&quot;,&quot;price&quot;:50,num:1&#125;)\ndb.order_item.insert(&#123;&quot;order_id&quot;:&quot;1&quot;,&quot;title&quot;:&quot;商品键盘 3&quot;,&quot;price&quot;:0,num:1&#125;)\ndb.order_item.insert(&#123;&quot;order_id&quot;:&quot;2&quot;,&quot;title&quot;:&quot;牛奶&quot;,&quot;price&quot;:50,num:1&#125;)\ndb.order_item.insert(&#123;&quot;order_id&quot;:&quot;2&quot;,&quot;title&quot;:&quot;酸奶&quot;,&quot;price&quot;:40,num:1&#125;)\ndb.order_item.insert(&#123;&quot;order_id&quot;:&quot;3&quot;,&quot;title&quot;:&quot;矿泉水&quot;,&quot;price&quot;:2,num:5&#125;)\ndb.order_item.insert(&#123;&quot;order_id&quot;:&quot;3&quot;,&quot;title&quot;:&quot;毛巾&quot;,&quot;price&quot;:10,num:1&#125;)\n\n$project自定义文档的结构，可以用来重命名、增加或删除文档中的字段\n查找 order 只返回文档中 trade_no 和 all_price 字段\ndb.order.aggregate([\n    &#123;\n        $project: &#123;\n            trade_no: 1,\n            all_price: 1\n        &#125;\n    &#125;\n])\n\n$match过滤。用法类似于 find() 方法中的参数\ndb.order.aggregate([\n    &#123;\n        $project: &#123; trade_no: 1, all_price: 1 &#125;\n    &#125;,\n    &#123;\n        $match: &#123; all_price: &#123; $gte: 90 &#125; &#125;\n    &#125;\n])\n\n$group分组，可用于统计结果\ndb.order_item.aggregate([\n    &#123;\n        $group: &#123; _id: &#39;$order_id&#39;, total: &#123; $sum: &#39;$num&#39; &#125; &#125;\n    &#125;\n])\n\n$sort排序\ndb.order.aggregate([\n    &#123;\n        $project: &#123; trade_no: 1, all_price: 1 &#125;\n    &#125;,\n    &#123;\n        $sort: &#123; all_price: -1 &#125;\n    &#125;\n])\n\n$limit限制数量\ndb.order.aggregate([\n    &#123;\n        $project: &#123; trade_no: 1, all_price: 1 &#125;\n    &#125;,\n    &#123;\n        $limit: 1\n    &#125;\n])\n\n$skip跳过\ndb.order.aggregate([\n    &#123;\n        $project: &#123; trade_no: 1, all_price: 1 &#125;\n    &#125;,\n    &#123;\n        $skip: 1\n    &#125;\n])\n\n$lookup表关联\ndb.order.aggregate([\n    &#123;\n        $lookup: &#123;\n            from: &#39;order_item&#39;,\n            localField: &#39;order_id&#39;,\n            foreignField: &#39;order_id&#39;,\n            as: &#39;items&#39;\n        &#125;\n    &#125;\n])\n\n综合运用db.order.aggregate([\n    &#123;\n        $lookup: &#123;\n            from: &#39;order_item&#39;,\n            localField: &#39;order_id&#39;,\n            foreignField: &#39;order_id&#39;,\n            as: &#39;items&#39;\n        &#125;\n    &#125;,\n    &#123;\n        $match: &#123;\n            all_price: &#123;\n                $gt: 90\n            &#125;\n        &#125;\n    &#125;,\n    &#123;\n        $project: &#123;\n            items: 1\n        &#125;\n    &#125;\n])\n\n\n","slug":"MongoDB高级查询","date":"2019-08-26T00:00:00.000Z","categories_index":"数据库","tags_index":"MongoDB","author_index":"ZV"},{"id":"55fb07a4dbf6f44614d26c9d54b2e72f","title":"二进制","content":"什么是二进制计数法？53 的十进制表达\n53 &#x3D; 5*10^1 + 3*10^0\n\n53 的二进制表达\n53 &#x3D; 1*2^5 + 1*2^4 + 0*2^3 + 1*2^2 + 0*2^1 + 1*2^0   \n\nJavaScript 中 Number.prototype.toString 的模拟实现\nNumber.prototype.toStringFake &#x3D; function(base) &#123;\n    let decNumber &#x3D; this\n    let remArr &#x3D; []\n    let rem &#x3D; 0\n    while (decNumber &gt; 0) &#123;\n        rem &#x3D; Math.floor(decNumber % base)\n        if (rem &gt; 10) rem &#x3D; String.fromCharCode(rem + 87) &#x2F;&#x2F; 余数超过9以[a-f]显示\n        remArr.unshift(rem)\n        decNumber &#x3D; Math.floor(decNumber &#x2F; base)\n    &#125;\n    return remArr.join(&#39;&#39;)\n&#125;\n\nJavaScript 中 parseInt 的模拟实现\nconst parseIntFake &#x3D; (numText, dec &#x3D; 10) &#x3D;&gt; &#123;\n    return numText\n        .split(&#39;&#39;)\n        .reverse()\n        .reduce((prev, next, index) &#x3D;&gt; &#123;\n            next &#x3D; isNaN(+next) ? next.charCodeAt() - 87 : +next\n            return prev + Math.pow(dec, index) * next\n        &#125;, 0)\n&#125;\n","slug":"二进制","date":"2019-08-26T00:00:00.000Z","categories_index":"基础","tags_index":"数学","author_index":"ZV"},{"id":"c83a6d6824f2f22e4599f12b06607ba3","title":"余数","content":"前置知识余数总是在一个固定的范围内。\n整数是没有边界的，它可能是正无穷，也可能是负无穷。但是余数却可以通过某一种关系，让整数处于一个确定的边界内。\n同余定理：简单来说，就是两个整数 a 和 b，如果它们除以正整数 m 得到的余数相等，我们就可以说 a 和 b 对于模 m 同余。\n还有，我们经常提到的奇数和偶数，其实也是同余定理的一个应用。当然，这个应用里，它的模就是 2 了，2 除以 2 余 0，所以它是偶数；3 除以 2 余 1，所以它是奇数。2 和 4 除以 2 的余数都是 0，所以它们都是一类，都是偶数。3 和 5 除以 2 的余数都是 1，所以它们都是一类，都是奇数。\n简单来说， 同余定理其实就是用来分类的 。你知道，我们有无穷多个整数，那怎么能够全面、多维度地管理这些整数？同余定理就提供了一个思路。\n因为不管你的模是几，最终得到的余数肯定都在一个范围内。比如我们上面除以 7，就得到了星期几；我们除以 2，就得到了奇偶数。所以按照这种方式, 我们就可以把无穷多个整数分成有限多个类。\n哈希哈希有的时候也会被翻译为散列，简单来说，它就是 将任意长度的输入，通过哈希算法，压缩为某一固定长度的输出 \n\n在这个公式中，x 表示等待被转换的数值，而 size 表示有限存储空间的大小，mod 表示取余操作。 通过余数，你就能将任何数值，转换为有限范围内的一个数值，然后根据这个新的数值，来确定将数据存放在何处。\n让我以加密算法为例，举个例子，比如说我们要加密一组三位数，那我们设定一个这样的加密规则：\n\n先对每个三位数的个、十和百位数，都加上一个较大的随机数\n然后将每位上的数都除以 7，用所得的余数代替原有的个、十、百位数\n最后将第一位和第三位交换。\n\n&#x2F;&#x2F; 加密\nconst hashEncrypt &#x3D; (value, salt) &#x3D;&gt; &#123;\n    let valueList &#x3D; String(value).split(&#39;&#39;).map(item &#x3D;&gt; +item)\n    let result &#x3D; valueList.map(item &#x3D;&gt; &#123;\n        let quotient &#x3D; Math.floor((item + salt) &#x2F; 7)\n        let rem &#x3D; (item + salt) % 7\n        return &#123;\n            quotient,\n            rem\n        &#125;\n    &#125;)\n    let encryptValue &#x3D; +result.map(item &#x3D;&gt; item.rem).reverse().join(&#39;&#39;)\n    let iv &#x3D; result.map(item &#x3D;&gt; item.quotient)\n    return &#123;\n        encryptValue,\n        iv\n    &#125;\n&#125;\n&#x2F;&#x2F; 解密\nconst hashDecrypt &#x3D; (value, iv, salt) &#x3D;&gt; &#123;\n    let valueList &#x3D; String(value).split(&#39;&#39;).reverse().map(item &#x3D;&gt; +item)\n    let result &#x3D; valueList.map((item, index) &#x3D;&gt; &#123;\n        return iv[index] * 7 + item - salt\n    &#125;)\n    let decryptValue &#x3D; +result.join(&#39;&#39;)\n    return decryptValue\n&#125;\n\nlet testValue &#x3D; 751\nlet salt &#x3D; 4523645\nlet &#123; encryptValue, iv &#125; &#x3D; hashEncrypt(testValue, salt)\nlet decryptValue &#x3D; hashDecrypt(encryptValue, iv, salt)\n","slug":"余数","date":"2019-08-26T00:00:00.000Z","categories_index":"基础","tags_index":"数学","author_index":"ZV"},{"id":"15d1e9457069635d443cc237473de367","title":"关于进制的思考","content":"三个基本类型\nint\nfloat\nchar\n\n总结\nbit 二进制位\n计算机用来存储数据最基本的单位是电子管 有两种状态开启和关闭 即 0 和 1 这两种可能\n对应到计算机中的存储单位就是 bit\nn个bit可以表示 0 ~ 2^n - 1 这个区间的数\n\n\n\n\n\n二进制\n十进制\n\n\n\n0\n0\n\n\n1\n1\n\n\n10\n2\n\n\n11\n3\n\n\n100\n4\n\n\n101\n5\n\n\n110\n6\n\n\n111\n7\n\n\n\nByte\n在计算机中 8 个二进制位为一个字节 (B)，最常用的单位。\n所以可以得出 1 个 Byte 可以表示一个0 ~ 2^8 - 1大小的数\n\n进制\n进制只是数字的一种表现形式\n也就是说10 进制 32和2 进制的 100000其实是一样的 只是展现方式的有所不同 \n\nint 与 char 的关系\n在 C 语言中 int 与 char 是可以无缝转换的\n\nstring 类型的的本质是个数组\n&#x2F;&#x2F; 此时 a 是一个整形数字 即 int 类型\nlet a &#x3D; 100\t\t\t\t\t\t\n&#x2F;&#x2F; 由于 int 和 char 是相同的那么我们可以找到 ASCII 码为 100 的 char 即 &quot;d&quot;\nlet b &#x3D; String.fromCharCode(a)\t\n&#x2F;&#x2F; 然而把 a 从 int 转换成 string 得到 &quot;100&quot; 后其实得到的是一个装满 char 的一个数组\n&#x2F;&#x2F; 每一个 char 都可以找到它的 int 类型\nlet c &#x3D; a.toString()\t\t\t&#x2F;&#x2F; &quot;100&quot;\nc.charCodeAt(0)\t\t\t\t\t&#x2F;&#x2F; 54\nc.charCodeAt(1)\t\t\t\t\t&#x2F;&#x2F; 52\n\n同一个数由于进制不同而导致的显示方式不同并不影响他们相等\n但是一个 int 类型的 100 和一个 string 类型的 “100”是完全不同的\n存储一个 int 的 100 用 1 Byte 又就可以了\n存储一个 string 类型的 “100” 需要用 3 Byte （1 个 char 需要 1 Byte 大小的空间去存储）\n\n\n补充知识计算机存储单位的换算关系计算机存储单位一般用bit、B、KB、MB、GB、TB、PB、EB、ZB、YB、BB、NB、DB……来表示，它们之间的关系是：\n位 bit (比特)(Binary Digits)：存放一位二进制数，即 0 或 1，最小的存储单位。[英文缩写：b(固定小写)]\n字节byte：8个二进制位为一个字节(B)，最常用的单位。\n\n1 Byte (B) = 8 bit\n1 Kilo Byte (KB) = 1024 B\n1 Mega Byte (MB) = 1024 KB\n1 Giga Byte (GB) = 1024 MB\n1 Tera Byte (TB) = 1024 GB\n1 Peta Byte (PB) = 1024 TB\n1 Exa Byte (EB) = 1024 PB\n1 Zetta Byte (ZB) = 1024 EB\n1 Yotta Byte (YB) = 1024 ZB\n1 Bronto Byte (BB) = 1024 YB\n1 Nona Byte (NB) = 1024 BB\n1 Dogga Byte (DB) = 1024 NB\n1 Corydon Byte (CB) = 1024 DB\n\nJS 中整形转换成字节数组const intToBytes &#x3D; (value, len) &#x3D;&gt; &#123;\n    let int8Arr &#x3D; new Array(len)\n        for (let i &#x3D; 0; i &lt; len; i++) &#123;\n            int8Arr[i] &#x3D; (Math.floor(value &#x2F; Math.pow(256, i))) &amp; 0xff\n        &#125;\n    return int8Arr\n&#125;\nJS中10进制转任意进制  const divideByDec &#x3D; (decNumber, base) &#x3D;&gt; &#123;\n    let remArr &#x3D; []\n    let rem &#x3D; 0\n    while (decNumber &gt; 0) &#123;\n        rem &#x3D; Math.floor(decNumber % base)\n        if (rem &gt; 10) rem &#x3D; String.fromCharCode(rem + 87)\n        remArr.push(rem)\n        decNumber &#x3D; Math.floor(decNumber &#x2F; base)\n    &#125;\n    return remArr.reverse().join(&#39;&#39;)\n&#125;\n&#x2F;&#x2F; Math.floor() 方法返回小于等于x的最大整数。\n&#x2F;&#x2F; String.fromCharCode() 返回ASCII码对应的字符\nNumber.prototype.divideByDec &#x3D; function(base) &#123;\n    let decNumber &#x3D; this\n    let remArr &#x3D; []\n    let rem &#x3D; 0\n    while (decNumber &gt; 0) &#123;\n        rem &#x3D; Math.floor(decNumber % base)\n        if (rem &gt; 10) rem &#x3D; String.fromCharCode(rem + 87)\n        remArr.unshift(rem)\n        decNumber &#x3D; Math.floor(decNumber &#x2F; base)\n    &#125;\n    return remArr.join(&#39;&#39;)\n&#125;","slug":"关于进制的思考","date":"2019-08-26T00:00:00.000Z","categories_index":"基础","tags_index":"数学","author_index":"ZV"},{"id":"ef644e9a92c4e469f40c448b51b2e904","title":"小试 MongoDB","content":"常用命令\n\n\n命令\n作用\n\n\n\ncls\n清屏\n\n\nshow dbs\n查看所有数据库\n\n\nshow collections\n显示当前数据库中的所有集合\n\n\nNoSQL( Not Only SQL) vs SQLMySQL 中的许多概念在 MongoDB 中具有相近的类比。本表概述了每个系统中的一些常见概念。\n\n\n\nMySQL\nMongoDB\n\n\n\n表\n集合\n\n\n行\n文档\n\n\n列\n字段\n\n\njoins\n嵌入文档或者链接\n\n\n\n\n\n\n\n\n\n\n\n关系型数据库与 NoSQL 的对比\nNoSQL 还是 SQL ？这一篇讲清楚\n小白必须懂的 MongoDB 的十大总结\n连接数据库\n开启MongoDB服务\n  mongod --dbpath D:\\data\\db\n\n管理数据库\n  mongo 127.0.0.1:27017\n\n\n\n创建数据库\n使用并创建数据库\n use user\n\n在数据库user中的集合member中插入一条数据（集合需要通过向其插入数据进行创建）\n db.member.insert(&#123; name: &#39;Jack&#39; &#125;)\n\n删除数据库user中的集合member\n db.member.drop()\n\n删除数据库user\n use user &#x2F;&#x2F; 需要先使用数据库\ndb.dropDatabase();\n\n\n\n增删改查增加数据db.表名.insert(&#123; name: &#39;Jack&#39; &#125;)\n\n查找数据\n查找所有记录\n db.member.find()\n\n查询一个字段的所有值\n db.member.distinct(name)\n\n查询 age = 25 的记录\n db.member.find(&#123; age: 25 &#125;)\n\n查询 age &gt; 20 的记录\n db.member.find(&#123; age: &#123; $gt: 20 &#125; &#125;)\n\n查询 age &lt; 20 的记录\n db.member.find(&#123; age: &#123; $lt: 20 &#125; &#125;)\n\n查询 age &gt;= 20 的记录\n db.member.find(&#123; age: &#123; $gte: 20 &#125; &#125;)\n\n查询 age &gt;= 20 的记录\n db.member.find(&#123; age: &#123; $lte: 20 &#125; &#125;)\n\n查询 age &gt;= 20 并且 age &lt;= 25\n db.member.find(&#123; age: &#123; $gte: 20, $lte: 25 &#125; &#125;)\n\n查询 name 中包含 im 的记录\n db.member.find(&#123; name: &#x2F;im&#x2F; &#125;)\n\n查询 name 中以 J 开头的记录\ndb.member.find(&#123; name: &#x2F;^J&#x2F; &#125;)\n\n查询 name 中以 m 结尾的记录\ndb.member.find(&#123; name: &#x2F;m$&#x2F; &#125;)\n\n查询指定列 name 数据, age &gt; 20\ndb.member.find(&#123; age: &#123; $gt: 20 &#125; &#125;, &#123; name: 1 &#125;)\n\n按照年龄排序\ndb.member.find().sort(&#123; age: 1 &#125;) &#x2F;&#x2F; 升序\ndb.member.find().sort(&#123; age: -1 &#125;) &#x2F;&#x2F; 降序\n\n查询前 3 条数据\ndb.member.find().limit(3);\n\n查询 3 条以后的数据\ndb.member.find().skip(3);\n\n查询在 3-5 之间的数据\ndb.member\n    .find()\n    .limit(3)\n    .skip(2)\n\nor 查询（年龄为 19 或 25 的记录）\ndb.member.find(&#123;\n    $or: [&#123; age: 19 &#125;, &#123; age: 25 &#125;]\n&#125;)\n\nand 查询（年龄大于 20 的性别为男的记录）\ndb.member.find(&#123;\n    $and: [&#123; age: &#123; $gte: 25 &#125; &#125;, &#123; sex: true &#125;]\n&#125;)\n\n查询第一条数据\ndb.member.findOne()\ndb.member.find().limit(1)\n\n查询某个结果集的记录条数\ndb.member.find(&#123; age: &#123; $lte: 20 &#125; &#125;).count()\n\n\n\n修改数据\n查找名字叫做 Jack 的，把年龄更改为 30 岁：\n db.member.update(&#123; name: &#39;Jack&#39; &#125;, &#123; $set: &#123; age: 30 &#125; &#125;)\n\n\n\n删除数据\n删除 age = 20 岁的记录\n db.member.remove(&#123; age: 20 &#125;)\n\n删除 age &gt; 20 记录\n db.member.remove(&#123; age: &#123; $gt: 20 &#125; &#125;, &#123; justOne: true &#125;)\n\n删除 age = 20 的一条记录\n db.member.remove(&#123; age: 20 &#125;, &#123; justOne: true &#125;)\n\n删除集合\n db.member.drop()\n\n删除数据库\n db.dropDatabase()\n\n\n\nexplain获取查询时间（单位:毫秒）db.itemlist.find(&#123; name: &#39;xxx&#39; &#125;).explain(&#39;executionStats&#39;).executionStats.executionTimeMillis\n\n索引\n\n\n\n\n\n\n\n\n索引是对数据库表中一列或多列的值进行排序的一种结构\n索引通常能够极大的提高查询的效率，如果没有索引，MongoDB 在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。\n&#x2F;&#x2F; 创建一个50000条的数据\nfor (let i &#x3D; 0; i &lt; 50000; i++) &#123;\n    db.itemlist.insert(&#123;\n        name: &#39;item&#39; + i\n    &#125;)\n&#125;\n\n创建索引\n db.member.createIndex(&#123; name: 1 &#125;)\n\n获取当前集合的索引\n db.member.getIndexes()\n\n删除索引\n db.member.dropIndex(&#123; name: 1 &#125;)\n\n创建复合索引\n db.member.createIndex(&#123; name: 1, age: -1 &#125;)\n\n\n\n\n\n\n\n\n\n\n该索引被创建后，基于 name 和 age 的查询将会用到该索引，或者是基于 name 的查询也会用到该索引，但是只是基于 age 的查询将不会用到该复合索引。因此可以说，如果想用到复合索引，必须在查询条件中包含复合索引中的前 N 个索引列。\n然而如果查询条件中的键值顺序和复合索引中的创建顺序不一致的话，MongoDB 可以智能的帮助我们调整该顺序，以便使复合索引可以为查询所用。\ndb.member.find(&#123;age: 30, name: &quot;Jack&quot;&#125;)\n\n在创建索引时为其指定索引名\n db.member.createIndex(&#123; name: 1 &#125;, &#123; name: &#39;username&#39; &#125;)\n\n创建唯一索引\n 不允许具有索引值相同的行，从而禁止重复的索引或键值\n db.member.createIndex(&#123; name: 1 &#125;, &#123; unique: true &#125;)\n\n\n","slug":"小试MongoDB","date":"2019-08-26T00:00:00.000Z","categories_index":"数据库","tags_index":"MongoDB","author_index":"ZV"},{"id":"6d67bef0e99958bbe052ba14f314a410","title":"迭代法","content":"二分查找在[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]中查找&#39;f&#39;\nconst searchWord &#x3D; (dictionary, wordToFind) &#x3D;&gt; &#123;\n    let left &#x3D; 0\n    let right &#x3D; dictionary.length - 1\n    while (left &lt;&#x3D; right) &#123;\n        let middle &#x3D; Math.floor((left + right) &#x2F; 2)\n        if (dictionary[middle] &#x3D;&#x3D;&#x3D; wordToFind) &#123;\n            return true\n        &#125; else &#123;\n            if (dictionary[middle] &gt; wordToFind) &#123;\n                right &#x3D; middle - 1\n            &#125; else &#123;\n                left &#x3D; middle + 1\n            &#125;\n        &#125;\n    &#125;\n    return false\n&#125;\nlet dictionary &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;]\nlet wordToFind &#x3D; &#39;f&#39;\nsearchWord(dictionary, wordToFind)\n","slug":"迭代法","date":"2019-08-26T00:00:00.000Z","categories_index":"基础","tags_index":"数学","author_index":"ZV"}]