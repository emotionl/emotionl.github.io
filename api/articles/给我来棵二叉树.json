{"title":"给我来棵二叉树","uid":"f24dd06beb414de62fa30f4650dc3e1e","slug":"给我来棵二叉树","date":"2020-05-29T00:00:00.000Z","updated":"2021-06-22T10:16:30.101Z","comments":true,"path":"api/articles/给我来棵二叉树.json","keywords":"👨‍💻🎸🍺","cover":null,"content":"<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F; 声明节点\nclass Node &#123;\n  constructor(key) &#123;\n    this.key &#x3D; key\n    this.left &#x3D; null\n    this.right &#x3D; null\n  &#125;\n&#125;\n\nclass BST &#123;\n  constructor() &#123;\n    this.root &#x3D; null\n  &#125;\n  &#x2F;&#x2F; 新增节点\n  insert(key) &#123;\n    if (this.root &#x3D;&#x3D;&#x3D; null) &#123;\n      this.root &#x3D; new Node(key)\n    &#125; else &#123;\n      this._insertNode(this.root, key)\n    &#125;\n  &#125;\n  _insertNode(node, key) &#123;\n    if (node &#x3D;&#x3D;&#x3D; null) return\n    if (key &lt; node.key) &#123;\n      if (node.left &#x3D;&#x3D;&#x3D; null) &#123;\n        node.left &#x3D; new Node(key)\n      &#125; else &#123;\n        this._insertNode(node.left, key)\n      &#125;\n    &#125; else &#123;\n      if (node.right &#x3D;&#x3D;&#x3D; null) &#123;\n        node.right &#x3D; new Node(key)\n      &#125; else &#123;\n        this._insertNode(node.right, key)\n      &#125;\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 中序遍历\n  inOrder(callback) &#123;\n    this._inOrderNode(this.root, callback)\n  &#125;\n  _inOrderNode(node, callback) &#123;\n    if (node !&#x3D;&#x3D; null) &#123;\n      this._inOrderNode(node.left, callback)\n      callback(node.key)\n      this._inOrderNode(node.right, callback)\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 先序遍历\n  preOrder(callback) &#123;\n    this._preOrderNode(this.root, callback)\n  &#125;\n  _preOrderNode(node, callback) &#123;\n    if (node !&#x3D;&#x3D; null) &#123;\n      callback(node.key)\n      this._preOrderNode(node.left, callback)\n      this._preOrderNode(node.right, callback)\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 后续遍历\n  postOrder(callback) &#123;\n    this._postOrderNode(this.root, callback)\n  &#125;\n  _postOrderNode(node, callback) &#123;\n    if (node !&#x3D;&#x3D; null) &#123;\n      this._postOrderNode(node.left, callback)\n      this._postOrderNode(node.right, callback)\n      callback(node.key)\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 最小值\n  min() &#123;\n    return this._minNode(this.root)\n  &#125;\n  _minNode(node) &#123;\n    let currentNode &#x3D; node\n    while (currentNode !&#x3D;&#x3D; null &amp;&amp; currentNode.left !&#x3D;&#x3D; null) &#123;\n      currentNode &#x3D; currentNode.left\n    &#125;\n    return currentNode\n  &#125;\n  &#x2F;&#x2F; 最大值\n  max() &#123;\n    return this._maxNode(this.root)\n  &#125;\n  _maxNode(node) &#123;\n    let currentNode &#x3D; node\n    while (currentNode !&#x3D;&#x3D; null &amp;&amp; currentNode.right !&#x3D;&#x3D; null) &#123;\n      currentNode &#x3D; currentNode.right\n    &#125;\n    return currentNode\n  &#125;\n  &#x2F;&#x2F; 搜索节点\n  search(key) &#123;\n    return this._searchNode(this.root, key)\n  &#125;\n  _searchNode(node, key) &#123;\n    if (node &#x3D;&#x3D;&#x3D; null) &#123;\n      return false\n    &#125;\n    if (key &lt; node.key) &#123;\n      return this._searchNode(node.left, key)\n    &#125; else if (key &gt; node.key) &#123;\n      return this._searchNode(node.right, key)\n    &#125; else &#123;\n      return true\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 移除节点\n  remove(key) &#123;\n    this.root &#x3D; this._removeNode(this.root, key)\n  &#125;\n  _removeNode(node, key) &#123;\n    &#x2F;&#x2F; 节点为空 返回null\n    if (node &#x3D;&#x3D;&#x3D; null) return null\n    &#x2F;&#x2F; key 小于或大于 node.key 继续调用 _removeNode\n    if (key &lt; node.key) &#123;\n      node.left &#x3D; this._removeNode(node.left, key)\n      return node\n    &#125; else if (key &gt; node.key) &#123;\n      node.right &#x3D; this._removeNode(node.right, key)\n      return node\n    &#125; else &#123;\n      &#x2F;&#x2F; key 等于 node.key\n      &#x2F;&#x2F; 第一种情况 搜索到的 node 没有左子树和右子树\n      if (node.left &#x3D;&#x3D;&#x3D; null &amp;&amp; node.right &#x3D;&#x3D;&#x3D; null) &#123;\n        return null\n      &#125;\n      &#x2F;&#x2F; 第二种情况 搜索到的 node 只有一个左子树或右子树\n      if (node.left &#x3D;&#x3D;&#x3D; null) &#123;\n        node &#x3D; node.right\n        return node\n      &#125; else if (node.right &#x3D;&#x3D;&#x3D; null) &#123;\n        node &#x3D; node.left\n        return node\n      &#125;\n      &#x2F;&#x2F; 第三种情况 搜索到的 node 不仅有左子树还有右子树\n      &#x2F;&#x2F; (1) 当找到了要移除的节点后，需要找到它右边子树中最小的节点。\n      &#x2F;&#x2F; (2) 然后，用它右侧子树中最小节点的键去更新这个节点的值。通过这一步，我们改变了这个节点的键，也就是说它被移除了。\n      &#x2F;&#x2F; (3) 但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的最小节点移除，毕竟它已经被移至要移除的节点的位置了。\n      &#x2F;&#x2F; (4) 最后，向它的父节点返回更新后节点的引用。\n      const aux &#x3D; this._minNode(node.right) &#x2F;&#x2F; 找到搜索到的 node 的右子树中的最小节点\n      node.key &#x3D; aux.key &#x2F;&#x2F; 把 aux 的 key 赋值给搜索到的 node\n      node.right &#x3D; this._removeNode(node.right, aux.key) &#x2F;&#x2F; 递归调用 removeNode 用于删除 aux 这个节点\n      return node\n    &#125;\n  &#125;\n&#125;\n\nconst bst &#x3D; new BST()\nconst keyList &#x3D; [5, 4, 3, 7, 6, 8, 2]\nkeyList.forEach(key &#x3D;&gt; bst.insert(key))\nconsole.log(bst)\nconst print &#x3D; val &#x3D;&gt; console.log(val)\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nbst.inOrder(print)\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nbst.preOrder(print)\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nbst.postOrder(print)\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nconsole.log(bst.min())\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nconsole.log(bst.max())\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nconsole.log(&#96;key 2 $&#123;bst.search(2) ? &#39;is exist&#39; : &#39;not exist&#39;&#125;&#96;)\nconsole.log(&#96;key 3 $&#123;bst.search(3) ? &#39;is exist&#39; : &#39;not exist&#39;&#125;&#96;)\nconsole.log(&#96;key 10 $&#123;bst.search(10) ? &#39;is exist&#39; : &#39;not exist&#39;&#125;&#96;)\nconsole.log(&#96;key 6 $&#123;bst.search(100) ? &#39;is exist&#39; : &#39;not exist&#39;&#125;&#96;)\nconsole.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)\nbst.remove(8)\nbst.remove(7)\nbst.remove(2)\nbst.inOrder(print)</code></pre>\n\n","text":"&#x2F;&#x2F; 声明节点 class Node &#123; constructor(key) &#123; this.key &#x3D; key this.left &#x3D; null this.right &#x3D; null &#125; &#125; c...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"基础","slug":"基础","count":9,"path":"api/categories/基础.json"}],"tags":[{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"}],"toc":"","author":{"name":"ZV","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"致过去的时光","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"实现一个集合","uid":"3db723625fe9f0ccdae76ec1059696b7","slug":"实现一个集合","date":"2020-06-04T00:00:00.000Z","updated":"2021-06-22T10:16:30.101Z","comments":true,"path":"api/articles/实现一个集合.json","keywords":"👨‍💻🎸🍺","cover":null,"text":"class CustomSet &#123; constructor() &#123; this.items &#x3D; &#123;&#125; &#125; getKeyForValue(value) &#123; return Symbol.for(value) &#12...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"基础","slug":"基础","count":9,"path":"api/categories/基础.json"}],"tags":[{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"}],"author":{"name":"ZV","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"致过去的时光","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"面向对象和原型","uid":"ee82dc5d42257715d56dbfc6d3d2929b","slug":"面向对象和原型","date":"2020-05-29T00:00:00.000Z","updated":"2021-06-22T10:16:30.101Z","comments":true,"path":"api/articles/面向对象和原型.json","keywords":"👨‍💻🎸🍺","cover":null,"text":"实现 new 操作首先，我们先来看看new操作起了什么作用 &#x2F;&#x2F; 构造函数 People (无显式返回值) function People(name, age) &#123; this.name &#x3D; name this.age &#x3D; age ...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"前端","slug":"前端","count":17,"path":"api/categories/前端.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":14,"path":"api/tags/JavaScript.json"}],"author":{"name":"ZV","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"致过去的时光","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}