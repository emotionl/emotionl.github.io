{"title":"单例模式","uid":"5e422a9b2c69bd7294ec71b84cbbb53b","slug":"单例模式","date":"2021-03-02T00:47:39.000Z","updated":"2021-06-22T10:16:30.101Z","comments":true,"path":"api/articles/单例模式.json","keywords":"👨‍💻🎸🍺","cover":null,"content":"<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>以数据库连接为例简单实现一个单例</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Database &#123;\n  constructor(options) &#123;\n    this.options &#x3D; options\n  &#125;\n  getConnection() &#123;\n    console.log(&#39;You are now connected to the database.&#39;)\n  &#125;\n&#125;\n\nconst DatabaseSingleton &#x3D; (function () &#123;\n  let instance &#x3D; null\n  return function (options) &#123;\n    if (instance &#x3D;&#x3D;&#x3D; null) &#123;\n      instance &#x3D; new Database(options)\n    &#125;\n    return instance\n  &#125;\n&#125;)()\n\nconst db1 &#x3D; new DatabaseSingleton(&#123; host: &#39;localhost&#39;, port: 1111 &#125;)\nconst db2 &#x3D; new DatabaseSingleton(&#123; host: &#39;localhost&#39;, port: 2222 &#125;)\nconsole.log(db1 &#x3D;&#x3D;&#x3D; db2) &#x2F;&#x2F; true</code></pre>\n\n<h2 id=\"通用实现\"><a href=\"#通用实现\" class=\"headerlink\" title=\"通用实现\"></a>通用实现</h2><p>通用的单例模式一般由以下几个部分构成</p>\n<ul>\n<li><strong>Singleton</strong> ：特定类，这是我们需要访问的类，访问者要拿到的是它的实例；</li>\n<li><strong>instance</strong> ：单例，是特定类的实例，特定类一般会提供 <code>getInstance</code> 方法来获取该单例；</li>\n<li><strong>getInstance</strong> ：获取单例的方法，或者直接由 <code>new</code> 操作符获取；</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">class Singleton &#123;\n  static instance &#x3D; null\n  static getInstance(options) &#123;\n    if (Singleton.instance &#x3D;&#x3D;&#x3D; null) &#123;\n      return new Singleton(options)\n    &#125;\n    return Singleton.instance\n  &#125;\n  constructor(options) &#123;\n    if (Singleton.instance &#x3D;&#x3D;&#x3D; null) &#123;\n      this.options &#x3D; options\n      Singleton.instance &#x3D; this\n    &#125;\n    return Singleton.instance\n  &#125;\n&#125;\n\nconst s1 &#x3D; new Singleton(&#39;s1&#39;)\nconst s2 &#x3D; Singleton.getInstance(&#39;s2&#39;)\nconsole.log(s1 &#x3D;&#x3D;&#x3D; s2) &#x2F;&#x2F; true</code></pre>\n\n<h2 id=\"懒汉式-vs-饿汉式\"><a href=\"#懒汉式-vs-饿汉式\" class=\"headerlink\" title=\"懒汉式 vs 饿汉式\"></a>懒汉式 vs 饿汉式</h2><p>懒汉式和饿汉式的区别就在于单例 <strong>instance</strong> 是否是懒加载的</p>\n<h3 id=\"懒汉式\"><a href=\"#懒汉式\" class=\"headerlink\" title=\"懒汉式\"></a>懒汉式</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Money(currency, amount) &#123;\n  this.currency &#x3D; currency\n  this.amount &#x3D; amount\n&#125;\n\nMoney.prototype.getMoney &#x3D; function () &#123;\n  return &#96;$&#123;this.currency&#125; $&#123;this.amount&#125;&#96;\n&#125;\n\nconst MoneySingletonLazy &#x3D; (function () &#123;\n  let instance &#x3D; null\n  return function (currency, amount) &#123;\n    if (instance &#x3D;&#x3D;&#x3D; null) &#123;\n      instance &#x3D; new Money(currency, amount) &#x2F;&#x2F; 懒加载\n    &#125;\n    return instance\n  &#125;\n&#125;)()\n\nconst m1 &#x3D; MoneySingletonLazy(&#39;$&#39;, 100)\nconst m2 &#x3D; MoneySingletonLazy(&#39;$&#39;, 100)\nconsole.log(m1 &#x3D;&#x3D;&#x3D; m2)</code></pre>\n\n<h3 id=\"饿汉式\"><a href=\"#饿汉式\" class=\"headerlink\" title=\"饿汉式\"></a>饿汉式</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Money(currency, amount) &#123;\n  this.currency &#x3D; currency\n  this.amount &#x3D; amount\n&#125;\n\nMoney.prototype.getMoney &#x3D; function () &#123;\n  return &#96;$&#123;this.currency&#125; $&#123;this.amount&#125;&#96;\n&#125;\n\nconst MoneySingletonHungry &#x3D; (function (currency, amount) &#123;\n  const instance &#x3D; new Money(currency, amount) &#x2F;&#x2F; 直接加载\n  return function () &#123;\n    return instance\n  &#125;\n&#125;)(&#39;$&#39;, 100)\n\nconst m1 &#x3D; MoneySingletonHungry()\nconst m2 &#x3D; MoneySingletonHungry()\nconsole.log(m1 &#x3D;&#x3D;&#x3D; m2)</code></pre>\n\n<h2 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li>单例模式在创建后在内存中只存在一个实例，节约了内存开支和实例化时的性能开支，特别是需要重复使用一个创建开销比较大的类时，比起实例不断地销毁和重新实例化，单例能节约更多资源，比如数据库连接；</li>\n<li>单例模式可以解决对资源的多重占用，比如写文件操作时，因为只有一个实例，可以避免对一个文件进行同时操作；</li>\n<li>只使用一个实例，也可以减小垃圾回收机制 GC（Garbage Collecation） 的压力，表现在浏览器中就是系统卡顿减少，操作更流畅，CPU 资源占用更少；</li>\n</ol>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ol>\n<li>单例模式对扩展不友好，一般<strong>不容易扩展</strong>，因为单例模式一般自行实例化，没有接口；</li>\n<li><strong>与单一职责原则冲突</strong>，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化；</li>\n</ol>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><ol>\n<li>当一个类的<strong>实例化过程消耗的资源过多</strong>，可以使用单例模式来避免性能浪费；</li>\n<li>当项目中需要一个公共的状态，那么需要使用单例模式来<strong>保证访问一致性</strong>；</li>\n</ol>\n","text":"代码实现以数据库连接为例简单实现一个单例 class Database &#123; constructor(options) &#123; this.options &#x3D; options &#125; getConnection() &#123; console.log...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"前端","slug":"前端","count":17,"path":"api/categories/前端.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":14,"path":"api/tags/JavaScript.json"},{"name":"设计模式","slug":"设计模式","count":1,"path":"api/tags/设计模式.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%9A%E7%94%A8%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">通用实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%87%92%E6%B1%89%E5%BC%8F-vs-%E9%A5%BF%E6%B1%89%E5%BC%8F\"><span class=\"toc-text\">懒汉式 vs 饿汉式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%87%92%E6%B1%89%E5%BC%8F\"><span class=\"toc-text\">懒汉式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A5%BF%E6%B1%89%E5%BC%8F\"><span class=\"toc-text\">饿汉式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">优缺点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">优点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">缺点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">使用场景</span></a></li></ol>","author":{"name":"ZV","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"致过去的时光","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"对象链接的方法","uid":"0ec65ba286b3197dc2b4ec62da6fde2a","slug":"对象链接的方法","date":"2021-04-10T11:26:01.000Z","updated":"2021-06-22T10:16:30.101Z","comments":true,"path":"api/articles/对象链接的方法.json","keywords":"👨‍💻🎸🍺","cover":null,"text":"对象链接也叫 OLOO ( Objects Linked to Other Objects )， 说的直白一点就是对象 A 链接对象 B，对象 A 可以访问对象 B 的属性和方法。 举个🌰，我们创建一个工具对象 BasicFormatter，然后通过不同的方式创建可以访问 Bas...","link":"","photos":[],"count_time":{"symbolsCount":802,"symbolsTime":"1 mins."},"categories":[{"name":"前端","slug":"前端","count":17,"path":"api/categories/前端.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":14,"path":"api/tags/JavaScript.json"}],"author":{"name":"ZV","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"致过去的时光","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"100个单词-01","uid":"6e749354fe99cad36f08dba2ac6a28a4","slug":"100个单词-01","date":"2021-02-09T13:55:12.000Z","updated":"2021-06-22T10:16:30.101Z","comments":true,"path":"api/articles/100个单词-01.json","keywords":"👨‍💻🎸🍺","cover":null,"text":"01-10 词 译 distributed adj. 分布式的，分散式的 decentralized adj. 分散管理的 vt. 使分散；使分权（decentralize 的过去分词） deliver vt. 交付；发表；递送；释放；给予（打击） intermediate ad...","link":"","photos":[],"count_time":{"symbolsCount":"3.6k","symbolsTime":"3 mins."},"categories":[{"name":"拓展","slug":"拓展","count":10,"path":"api/categories/拓展.json"}],"tags":[{"name":"单词","slug":"单词","count":1,"path":"api/tags/单词.json"}],"author":{"name":"ZV","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"致过去的时光","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}