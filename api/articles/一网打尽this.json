{"title":"一网打尽this","uid":"b88101b328f136c8f25d5c4f4b2521da","slug":"一网打尽this","date":"2021-01-24T21:06:53.000Z","updated":"2021-06-22T10:16:30.101Z","comments":true,"path":"api/articles/一网打尽this.json","keywords":"👨‍💻🎸🍺","cover":null,"content":"<h2 id=\"例题组合-1：全局环境下的-this\"><a href=\"#例题组合-1：全局环境下的-this\" class=\"headerlink\" title=\"例题组合 1：全局环境下的 this\"></a>例题组合 1：全局环境下的 this</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function f1() &#123;\n  console.log(this)\n&#125;\nfunction f2() &#123;\n  &#39;use strict&#39;\n  console.log(this)\n&#125;\nf1() &#x2F;&#x2F; window\nf2() &#x2F;&#x2F; undefined</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const foo &#x3D; &#123;\n  bar: 10,\n  fn: function () &#123;\n    console.log(this)\n    console.log(this.bar)\n  &#125;\n&#125;\nvar fn1 &#x3D; foo.fn &#x2F;&#x2F; 相当于 window.fn1 &#x3D; foo.fn\nfn1() &#x2F;&#x2F; window undefined</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const foo &#x3D; &#123;\n  bar: 10,\n  fn: function () &#123;\n    console.log(this)\n    console.log(this.bar)\n  &#125;\n&#125;\nfoo.fn() &#x2F;&#x2F; foo 10</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>结论：在执行函数时，如果函数中的 this 是被上一级的对象所调用，那么 this 指向的就是上一级的对象；否则指向全局环境。</p></blockquote>\n<h2 id=\"例题组合-2：上下文对象调用中的-this\"><a href=\"#例题组合-2：上下文对象调用中的-this\" class=\"headerlink\" title=\"例题组合 2：上下文对象调用中的 this\"></a>例题组合 2：上下文对象调用中的 this</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const person &#x3D; &#123;\n  name: &#39;Lucas&#39;,\n  brother: &#123;\n    name: &#39;Mike&#39;,\n    fn: function () &#123;\n      return this.name\n    &#125;\n  &#125;\n&#125;\nconsole.log(person.brother.fn()) &#x2F;&#x2F; &#39;Mike&#39;\n&#x2F;&#x2F; 在这种嵌套的关系中，this 指向最后调用它的对象，因此输出将会是：Mike。</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const o1 &#x3D; &#123;\n  text: &#39;o1&#39;,\n  fn: function () &#123;\n    return this.text\n  &#125;\n&#125;\nconst o2 &#x3D; &#123;\n  text: &#39;o2&#39;,\n  fn: function () &#123;\n    return o1.fn()\n  &#125;\n&#125;\nconst o3 &#x3D; &#123;\n  text: &#39;o3&#39;,\n  fn: function () &#123;\n    var fn &#x3D; o1.fn\n    return fn()\n  &#125;\n&#125;\nconst o4 &#x3D; &#123;\n  text: &#39;o4&#39;,\n  fn: o1.fn\n&#125;\n\nconsole.log(o1.fn()) &#x2F;&#x2F; o1\nconsole.log(o2.fn()) &#x2F;&#x2F; o1\nconsole.log(o3.fn()) &#x2F;&#x2F; undefined\nconsole.log(o4.fn()) &#x2F;&#x2F; 04\n&#x2F;* \n  第一个 console 最简单，o1 没有问题。难点在第二个和第三个上面，关键还是看调用 this 的那个函数。 \n  第二个 console 的 o2.fn()，最终还是调用 o1.fn()，因此答案仍然是 o1。 \n  第三个，在进行 var fn &#x3D; o1.fn 赋值之后，是「裸奔」调用，因此这里的 this 指向 window，答案当然是 undefined。\n  第四个，this 指向最后调用它的对象，在 fn 执行时，挂到 o4 对象上即可，我们提前进行了赋值操作\n*&#x2F;</code></pre>\n\n<h2 id=\"例题组合-3：bind-call-apply-改变-this-指向\"><a href=\"#例题组合-3：bind-call-apply-改变-this-指向\" class=\"headerlink\" title=\"例题组合 3：bind/call/apply 改变 this 指向\"></a>例题组合 3：bind/call/apply 改变 this 指向</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 三者使用区别\nconst printName &#x3D; (firstName, lastName) &#x3D;&gt; console.log(&#96;$&#123;firstName&#125; $&#123;lastName&#125;&#96;)\n&#x2F;&#x2F; bind\nprintName.bind(null, &#39;Number&#39;, &#39;One&#39;)() &#x2F;&#x2F; 常见于 React 绑定事件\n&#x2F;&#x2F; call\nprintName.call(null, &#39;Number&#39;, &#39;Two&#39;)\n&#x2F;&#x2F; apply\nprintName.apply(null, [&#39;Number&#39;, &#39;Three&#39;])</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const foo &#x3D; &#123;\n  name: &#39;lucas&#39;,\n  logName: function () &#123;\n    return this.name\n  &#125;\n&#125;\n\nconst bar &#x3D; &#123;\n  name: &#39;mike&#39;\n&#125;\nconsole.log(foo.logName.bind(bar)()) &#x2F;&#x2F; mike\nconsole.log(foo.logName.call(bar)) &#x2F;&#x2F; mike\nconsole.log(foo.logName.apply(bar)) &#x2F;&#x2F; mike</code></pre>\n\n<h2 id=\"例题组合-4：构造函数和-this\"><a href=\"#例题组合-4：构造函数和-this\" class=\"headerlink\" title=\"例题组合 4：构造函数和 this\"></a>例题组合 4：构造函数和 this</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Foo() &#123;\n  this.bar &#x3D; &#39;Lucas&#39;\n&#125;\nconst instance &#x3D; new Foo()\nconsole.log(instance.bar)\n&#x2F;* \n  new 操作符调用构造函数，具体做了什么？以下供参考： \n  1.创建一个新的对象； \n  2.将构造函数的 this 指向这个新对象； \n  3.为这个对象添加属性、方法等； \n  4.最终返回新对象。\n\n  以上过程，也可以用代码表述：\n  var obj  &#x3D; &#123;&#125;\n  obj.__proto__ &#x3D; Foo.prototype\n  Foo.call(obj)\n*&#x2F;</code></pre>\n\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function Foo() &#123;\n  this.user &#x3D; &#39;Lucas&#39;\n  const o &#x3D; &#123;&#125;\n  return o\n&#125;\nfunction Bar() &#123;\n  this.user &#x3D; &#39;Lucas&#39;\n  return 1\n&#125;\nconsole.log(new Foo()) &#x2F;&#x2F; &#123;&#125;\nconsole.log(new Bar()) &#x2F;&#x2F; Bar &#123;user: &quot;Lucas&quot;&#125;\n&#x2F;* \n  结论：如果构造函数中显式返回一个值，且返回的是一个对象，那么 this 就指向这个返回的对象；\n  如果返回的不是一个对象，那么 this 仍然指向实例。\n*&#x2F;</code></pre>\n\n<h2 id=\"例题组合-5：箭头函数中的-this-指向\"><a href=\"#例题组合-5：箭头函数中的-this-指向\" class=\"headerlink\" title=\"例题组合 5：箭头函数中的 this 指向\"></a>例题组合 5：箭头函数中的 this 指向</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const foo &#x3D; &#123;\n  fn: function () &#123;\n    setTimeout(function () &#123;\n      console.log(this)\n    &#125;)\n  &#125;\n&#125;\nconst bar &#x3D; &#123;\n  fn: function () &#123;\n    setTimeout(() &#x3D;&gt; &#123;\n      console.log(this)\n    &#125;)\n  &#125;\n&#125;\n\nconsole.log(foo.fn()) &#x2F;&#x2F; window\nconsole.log(bar.fn()) &#x2F;&#x2F; &#123;fn: ƒ&#125;\n&#x2F;* \n  this 出现在 setTimeout() 中的匿名函数里，因此 this 指向 window 对象。\n  如果需要 this 指向 foo这个 object 对象，可以巧用箭头函数解决： \n*&#x2F;</code></pre>\n\n<h2 id=\"最后一道\"><a href=\"#最后一道\" class=\"headerlink\" title=\"最后一道\"></a>最后一道</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const bar &#x3D; &#123;\n  f1: function () &#123;\n    console.log(this)\n  &#125;,\n  f2: () &#x3D;&gt; &#123;\n    console.log(this)\n  &#125;,\n  f3: function () &#123;\n    const fun &#x3D; () &#x3D;&gt; &#123;\n      console.log(this)\n    &#125;\n    fun()\n  &#125;,\n  f4: () &#x3D;&gt; &#123;\n    function fun() &#123;\n      console.log(this)\n    &#125;\n    fun()\n  &#125;\n&#125;\n\nbar.f1() &#x2F;&#x2F; bar | f1 被 bar 调用，所以打印的 this 是 bar\nbar.f2() &#x2F;&#x2F; window | f2 的 this 是 f2 外层的 bar 的 this，所以打印的 this 是 window\nbar.f3() &#x2F;&#x2F; bar | f3 中 fun 的 this 是 fun 外层的 f3 的 this， f3 被 bar 调用，f3 的 this 是 bar，所以打印的 this 是 window\nbar.f4() &#x2F;&#x2F; f4 中的 fun 的执行属于普通函数调用，只是自执行，此时 fun 是一个全局函数，因此打印的 this 是 window\n\nconst f1 &#x3D; bar.f1\nf1() &#x2F;&#x2F; window\nconst f2 &#x3D; bar.f2\nf2() &#x2F;&#x2F; window\nconst f3 &#x3D; bar.f3\nf3() &#x2F;&#x2F; window\nconst f4 &#x3D; bar.f4\nf4() &#x2F;&#x2F; window</code></pre>\n","text":"例题组合 1：全局环境下的 thisfunction f1() &#123; console.log(this) &#125; function f2() &#123; &#39;use strict&#39; console.log(this) &#125; f1() &#x2...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"前端","slug":"前端","count":17,"path":"api/categories/前端.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":14,"path":"api/tags/JavaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98%E7%BB%84%E5%90%88-1%EF%BC%9A%E5%85%A8%E5%B1%80%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84-this\"><span class=\"toc-text\">例题组合 1：全局环境下的 this</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98%E7%BB%84%E5%90%88-2%EF%BC%9A%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E4%B8%AD%E7%9A%84-this\"><span class=\"toc-text\">例题组合 2：上下文对象调用中的 this</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98%E7%BB%84%E5%90%88-3%EF%BC%9Abind-call-apply-%E6%94%B9%E5%8F%98-this-%E6%8C%87%E5%90%91\"><span class=\"toc-text\">例题组合 3：bind&#x2F;call&#x2F;apply 改变 this 指向</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98%E7%BB%84%E5%90%88-4%EF%BC%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C-this\"><span class=\"toc-text\">例题组合 4：构造函数和 this</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98%E7%BB%84%E5%90%88-5%EF%BC%9A%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-this-%E6%8C%87%E5%90%91\"><span class=\"toc-text\">例题组合 5：箭头函数中的 this 指向</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%90%8E%E4%B8%80%E9%81%93\"><span class=\"toc-text\">最后一道</span></a></li></ol>","author":{"name":"ZV","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"致过去的时光","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"前端开发规范","uid":"2afb485f1ca3d275b575e077ea3a1ee9","slug":"前端开发规范","date":"2021-01-25T10:31:16.000Z","updated":"2021-06-22T10:16:30.101Z","comments":true,"path":"api/articles/前端开发规范.json","keywords":"👨‍💻🎸🍺","cover":null,"text":" 此规范基于 阿里前端开发规范 | Tim 并结合实际项目进行部分修改 一、编程规约(一) 命名规范1.1.1 项目命名全部采用小写方式， 以中划线分隔。 正例：mall-management-system 反例：mall_management-system / mallMana...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"前端","slug":"前端","count":17,"path":"api/categories/前端.json"}],"tags":[{"name":"规范","slug":"规范","count":1,"path":"api/tags/规范.json"}],"author":{"name":"ZV","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"致过去的时光","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Learning-The-Shell","uid":"594852812e8442355d6909ab675fc295","slug":"Learning-The-Shell","date":"2021-01-11T23:48:21.000Z","updated":"2021-06-22T10:16:30.101Z","comments":true,"path":"api/articles/Learning-The-Shell.json","keywords":"👨‍💻🎸🍺","cover":null,"text":"01 - What Is the shell 什么是脚本 命令 EN ZH date Displays the current time and date. 显示当前日期 cal Displays a calendar of thecurrent month. 显示日历 df D...","link":"","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"运维","slug":"运维","count":5,"path":"api/categories/运维.json"}],"tags":[{"name":"Linux","slug":"Linux","count":3,"path":"api/tags/Linux.json"}],"author":{"name":"ZV","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"致过去的时光","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}