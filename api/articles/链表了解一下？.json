{"title":"链表了解一下？","uid":"37a029b7298934d10b895fa948d82730","slug":"链表了解一下？","date":"2019-12-25T00:00:00.000Z","updated":"2021-06-22T10:16:30.101Z","comments":true,"path":"api/articles/链表了解一下？.json","keywords":"👨‍💻🎸🍺","cover":null,"content":"<pre class=\"line-numbers language-js\" data-language=\"js\"><code class=\"language-js\">&#x2F;&#x2F; 声明节点\nclass Node &#123;\n  constructor(value) &#123;\n    this.value &#x3D; value\n    this.next &#x3D; null\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 单链表\nclass SingleLinkedList &#123;\n  constructor() &#123;\n    this.head &#x3D; new Node(&#39;head&#39;)\n  &#125;\n  &#x2F;&#x2F; 末尾追加节点\n  append(value) &#123;\n    let currentNode &#x3D; this.head\n    while (currentNode.next !&#x3D;&#x3D; null) &#123;\n      currentNode &#x3D; currentNode.next\n    &#125;\n    let newNode &#x3D; new Node(value)\n    currentNode.next &#x3D; newNode\n    return newNode\n  &#125;\n  &#x2F;&#x2F; 根据value查找节点\n  findNodeByValue(value) &#123;\n    let currentNode &#x3D; this.head.next\n    while (currentNode !&#x3D;&#x3D; null &amp;&amp; currentNode.value !&#x3D;&#x3D; value) &#123;\n      currentNode &#x3D; currentNode.next\n    &#125;\n    return currentNode &#x3D;&#x3D;&#x3D; null ? -1 : currentNode\n  &#125;\n  &#x2F;&#x2F; 根据index查找节点\n  findNodeByIndex(index) &#123;\n    let currentNode &#x3D; this.head.next\n    let pos &#x3D; 0\n    while (currentNode !&#x3D;&#x3D; null &amp;&amp; pos !&#x3D;&#x3D; index) &#123;\n      currentNode &#x3D; currentNode.next\n      pos++\n    &#125;\n    return currentNode &#x3D;&#x3D;&#x3D; null ? -1 : currentNode\n  &#125;\n  &#x2F;&#x2F; 转化ArrayList\n  toArrayList() &#123;\n    let currentNode &#x3D; this.head.next\n    let arrayList &#x3D; []\n    while (currentNode !&#x3D;&#x3D; null) &#123;\n      arrayList.push(currentNode.value)\n      currentNode &#x3D; currentNode.next\n    &#125;\n    return arrayList\n  &#125;\n  &#x2F;&#x2F; 插入节点\n  insertAfter(newValue, value) &#123;\n    let prevNode &#x3D; this.findNodeByValue(value)\n    if (prevNode &#x3D;&#x3D;&#x3D; -1) &#123;\n      return -1\n    &#125; else &#123;\n      let newNode &#x3D; new Node(newValue)\n      newNode.next &#x3D; prevNode.next\n      prevNode.next &#x3D; newNode\n      return newNode\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 根据value查找value的前一个节点y\n  findPrevNodeByValue(value) &#123;\n    let currentNode &#x3D; this.head\n    while (currentNode.next !&#x3D;&#x3D; null &amp;&amp; currentNode.next.value !&#x3D;&#x3D; value) &#123;\n      currentNode &#x3D; currentNode.next\n    &#125;\n    return currentNode.next &#x3D;&#x3D;&#x3D; null ? -1 : currentNode\n  &#125;\n  &#x2F;&#x2F; 根据value删除节点\n  removeNodeByValue(value) &#123;\n    let prevNode &#x3D; this.findPrevNodeByValue(value)\n    if (prevNode &#x3D;&#x3D;&#x3D; -1) &#123;\n      return -1\n    &#125; else &#123;\n      prevNode.next &#x3D; prevNode.next.next\n      return this.toArrayList()\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 反转链表\n  reverse() &#123;\n    let currentNode &#x3D; this.head.next\n    let prevNode &#x3D; null\n    while (currentNode !&#x3D;&#x3D; null) &#123;\n      let nextNode &#x3D; currentNode.next\n      currentNode.next &#x3D; prevNode\n      prevNode &#x3D; currentNode\n      currentNode &#x3D; nextNode\n    &#125;\n    this.head.next &#x3D; prevNode\n    return this.toArrayList()\n  &#125;\n  &#x2F;&#x2F; 清空链表\n  clear() &#123;\n    this.head.next &#x3D; null\n    return this.toArrayList()\n  &#125;\n  &#x2F;&#x2F; 数组转单链表\n  static arrayToLinkedList(arrayList) &#123;\n    if (!Array.isArray(arrayList)) &#123;\n      return -1\n    &#125; else &#123;\n      let sll &#x3D; new SingleLinkedList()\n      for (let i &#x3D; 0; i &lt; arrayList.length; i++) &#123;\n        let value &#x3D; arrayList[i]\n        sll.append(value)\n      &#125;\n      return sll\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 环验证\n  checkCircle() &#123;\n    let slow &#x3D; this.head\n    let fast &#x3D; this.head.next\n    while (fast !&#x3D;&#x3D; null &amp;&amp; fast.next !&#x3D;&#x3D; null) &#123;\n      fast &#x3D; fast.next.next\n      slow &#x3D; slow.next\n      console.log(&#96;+++++++++++++++++++++++++&#96;)\n      console.log(&#39;slow&#39;, slow)\n      console.log(&#39;fast&#39;, fast)\n      console.log(&#96;+++++++++++++++++++++++++&#96;)\n      if (slow &#x3D;&#x3D; fast) return true\n    &#125;\n    return false\n  &#125;\n&#125;\n\nlet sll &#x3D; new SingleLinkedList()\nfor (let i &#x3D; 0; i &lt; 5; i++) &#123;\n  sll.append(&#96;num $&#123;i&#125;&#96;)\n&#125;\n&#x2F;&#x2F; console.log(sll.toArrayList())\n&#x2F;&#x2F; console.log(sll.findNodeByIndex(2))\n&#x2F;&#x2F; console.log(sll.findNodeByValue(&#39;num 3&#39;))\n&#x2F;&#x2F; console.log(sll.insertAfter(&#39;xxx&#39;, &#39;num 3&#39;))\n&#x2F;&#x2F; console.log(sll.removeNodeByValue(&#39;num 1&#39;))\n&#x2F;&#x2F; console.log(SingleLinkedList.arrayToLinkedList([4, 2, 3, 6, 7]))\n\n&#x2F;&#x2F; 环验证测试\nconsole.log(sll.checkCircle())\nlet n2 &#x3D; sll.findNodeByIndex(2)\nlet n4 &#x3D; sll.findNodeByIndex(4)\nn4.next &#x3D; n2\nconsole.log(sll.checkCircle())\n</code></pre>\n\n","text":"&#x2F;&#x2F; 声明节点 class Node &#123; constructor(value) &#123; this.value &#x3D; value this.next &#x3D; null &#125; &#125; &#x2F;&#x2F; 单链表 c...","link":"","photos":[],"count_time":{"symbolsCount":"4.6k","symbolsTime":"4 mins."},"categories":[{"name":"基础","slug":"基础","count":9,"path":"api/categories/基础.json"}],"tags":[{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"}],"toc":"","author":{"name":"ZV","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"致过去的时光","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"移动Web开发","uid":"f7ee095c73b7adf12560106c216e64a2","slug":"移动Web开发","date":"2019-12-25T00:00:00.000Z","updated":"2021-06-22T10:16:30.101Z","comments":true,"path":"api/articles/移动Web开发.json","keywords":"👨‍💻🎸🍺","cover":null,"text":" 运行在手机端的 Web页面（H5页面） 跨平台 基于Webview 告别IE拥抱Webkit 更好的适配和性能要求 常见移动web适配方法PC 960px / 1000px 居中 盒子模型，定高，定宽 display:inline-block 移动web 定高，宽度百分比 Fl...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"前端","slug":"前端","count":17,"path":"api/categories/前端.json"}],"tags":[{"name":"JavaScript","slug":"JavaScript","count":14,"path":"api/tags/JavaScript.json"},{"name":"移动端","slug":"移动端","count":1,"path":"api/tags/移动端.json"},{"name":"CSS","slug":"CSS","count":1,"path":"api/tags/CSS.json"}],"author":{"name":"ZV","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"致过去的时光","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"分析一下这段代码的时间复杂度","uid":"27dde8e157ab6a19ae6c30873f9e3622","slug":"分析一下这段代码的时间复杂度","date":"2019-12-24T00:00:00.000Z","updated":"2021-06-22T10:16:30.101Z","comments":true,"path":"api/articles/分析一下这段代码的时间复杂度.json","keywords":"👨‍💻🎸🍺","cover":null,"text":"let array &#x3D; new Array(10) let len &#x3D; 10 let i &#x3D; 0 &#x2F;&#x2F; 向数组中添加一个元素 function add(element) &#123; &#x2F;&#x2F; 数组空间不够了 &#...","link":"","photos":[],"count_time":{"symbolsCount":"1.2k","symbolsTime":"1 mins."},"categories":[{"name":"基础","slug":"基础","count":9,"path":"api/categories/基础.json"}],"tags":[{"name":"算法","slug":"算法","count":4,"path":"api/tags/算法.json"}],"author":{"name":"ZV","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"致过去的时光","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}